{"componentChunkName":"component---src-pages-projects-js","path":"/projects/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"00c381f0-5710-5155-9c28-698fcbcdcf68","html":"<p><strong>Poline</strong> is a little programming language I wrote to learn\nabout implementing Green Threading. The language\ndoesn't feature much more than string litterals, and mechanisms\nfor spawning threads and communicating between them.</p>\n<p>Green Threads allow many logical threads in a program to\nexecute on a limited number of actual OS threads. They\ncan be preempted off if they invoke a blocking operation.</p>\n<!--more-->","frontmatter":{"title":"Poline","description":"Tiny Language with Green Threading","tech":["Rust","Programming Languages"],"link":"https://github.com/cronokirby/poline","image":"/print6.jpg"}}},{"node":{"id":"94cb3159-15bf-5c00-8b9e-f389f4895133","html":"<p><strong>Ginkou</strong> is a program to build up a corpus of searchable sentences.\n<strong>Ginkou</strong> can consume Japanese sentences from the command line, or from a text\nfile, parse those sentences into words, and then index those sentences for\neasy retrieval. Given a word, <strong>Ginkou</strong> can look up sentences containing\nthat word, even if it's in a different form, such as a conjugated verb.</p>\n<!--more-->","frontmatter":{"title":"Ginkou","description":"Japanese Sentence Bank","tech":["Rust","SQLite"],"link":"https://github.com/cronokirby/ginkou","image":"/projects/ginkou.png"}}},{"node":{"id":"fab81037-e843-53ac-abf9-f9bf0c779090","html":"<p>This is a library providing a handful of persistent data structures for Typescript.\nThis includes immutable collections like linked-lists, and clojure-style vectors.\nPersistent data structures are immutable, but can efficiently share data between instances,\nand are thus more efficient than a normal copy-on-write collection when working without mutation.</p>\n<!--more-->","frontmatter":{"title":"Persistent-ts","description":"Persistent Data Structures","tech":["Typescript","Data Structures"],"link":"https://github.com/cronokirby/persistent-ts","image":"/projects/persistent.png"}}},{"node":{"id":"e2a1e756-bcda-59ff-bf12-e825545a50ec","html":"<p>This is a program that can take a folder of CSV files and serve them as a REST API.\nThe program also uses a JSON file for each file, to specify how each column maps to a JSON\nfield. The program is written in Go to make use of the built-in HTTP server.</p>\n<!--more-->","frontmatter":{"title":"Serve-csv","description":"REST API from CSV Files","tech":["Go","REST APIs","Backend"],"link":"https://github.com/cronokirby/serve-csv","image":"/projects/serve-csv.jpg"}}},{"node":{"id":"e22c186b-903a-53c3-8373-922f37409057","html":"<p><strong>Haze</strong> is a complete bittorrent client, capable of downloading any kind\nof torrent found in the wild. Bittorrent is a peer-to-peer protocol, where a client\njoins a large swarm of peers in order to download a file of common interest. Haskell was\nused in order to help manage the concurrency involved in communicating with a large number of\npeers.</p>\n<!--more-->","frontmatter":{"title":"Haze","description":"Bittorrent Client","tech":["Haskell","Networking"],"link":"https://github.com/cronokirby/haze","image":"/projects/haze.gif"}}},{"node":{"id":"70bfa44e-0a6e-5c5c-8c75-807e27431e13","html":"<p><a href=\"https://cronokirby.github.io/dex\">Live</a>.\n<strong>Dex</strong> is a little frontend app for searching and seeing stats about Pokemon, made with Vue.\nThe app wraps around the <a href=\"https://pokeapi.co/\">pokeapi</a> REST API for information about each Pokemon.</p>\n<!--more-->","frontmatter":{"title":"Dex","description":"Pokedex Viewing App","tech":["Javascript","Vue","REST APIs"],"link":"https://github.com/cronokirby/dex","image":"/projects/dex.png"}}},{"node":{"id":"11877bd8-e2c9-5b7d-9bee-8eb9b0bd816d","html":"<p><strong>Ripple</strong> is a program implementing a small decentralised chat protocol, written in <em>Go</em>.\nThe protocol involves participating nodes ferrying messages to eachother in a ring like fashion.\nNew nodes can join the chat by talking to any of the existing nodes in the swarm. <em>Go</em> is used for\nsimple networking and concurrency, as well as to provide both a command line, and a graphical terminal interface.\n<a href=\"/posts/notes-on-ripple/\">Read More</a></p>\n<!--more-->","frontmatter":{"title":"Ripple","description":"Decentralised Chat Protocol","tech":["Go","Concurrency","Networking"],"link":"https://github.com/cronokirby/ripple","image":"/projects/ripple.jpg"}}},{"node":{"id":"65a938a0-5a6d-5213-ba0a-5ca7878f0da7","html":"<p>This is a CLI program using <em>Huffman Coding</em> to compress files. The program is written in <em>Rust</em>\nfor efficiency.</p>\n<!--more-->","frontmatter":{"title":"Huffman-rs","description":"File Compressor","tech":["Rust","Compression"],"link":"https://github.com/cronokirby/bittrickle","image":"/projects/huffman.jpg"}}},{"node":{"id":"c1ef7388-7355-562e-a7db-84fc965a51b1","html":"<p><strong>Bittrickle</strong> is an implementation of Bittorrent's UDP tracker protocol. A tracker keeps\ntrack of peers participating in a bittorrent swarms, sharing files. Peers communicate with\nthe tracker in order to learn about each other. This implementation uses <em>Rust</em> because of its\nbuilt-in UDP networking.</p>\n<!--more-->","frontmatter":{"title":"Bittrickle","description":"UDP Bittorrent Tracker","tech":["Rust","Networking"],"link":"https://github.com/cronokirby/bittrickle","image":"/projects/trickle.jpg"}}},{"node":{"id":"3829c186-c380-57dc-966c-ac4490ef6dc5","html":"<p><strong>Cauchy</strong> is a program to generate plots of complex functions, written in <em>Rust</em>\n<strong>Cauchy</strong> is hardware-accelerated, using <em>OpenGL</em> to generate the plots using the GPU.</p>\n<!--more-->","frontmatter":{"title":"Cauchy","description":"Complex Function Plotter","tech":["Rust","OpenGL"],"link":"https://github.com/cronokirby/cauchy","image":"/projects/cauchy.png"}}},{"node":{"id":"3b4368fb-fa65-5481-a5f4-39b02905d4f3","html":"<p>This is a CLI program that can recreate a music library on a new machine by downloading\nthe files from various sources across the web. The program parses a file\nwith a hierarchical description of the library to replicate , and reproduces\nthat structure by consuming the sources described.\nThe program can also split up larger albums (via FFmpeg) into individual songs if necessary.</p>\n<!--more-->","frontmatter":{"title":"Populate","description":"Music Library Cloner","tech":["Haskell","FFmpeg","Rest APIs"],"link":"https://github.com/cronokirby/populate","image":"/projects/populate.png"}}},{"node":{"id":"ed74a5a4-3633-5766-89b4-16d98829b4c5","html":"<p>This is a CLI program to take a folder of songs and play them in a random order.\nSDL's audio subsystem is used to play audio files. This program was built to accompany\n<a href=\"https://github.com/cronokirby/populate\">populate</a>, which generates folders filled with songs,\nready for consumption by this program.</p>\n<!--more-->","frontmatter":{"title":"Darby","description":"Song Shuffler","tech":["Haskell","SDL"],"link":"https://github.com/cronokirby/darby","image":"/projects/darby.png"}}},{"node":{"id":"5065eabb-f703-5d23-947c-01534652f13d","html":"<p><a href=\"https://cronokirby.github.io/peerbin/#/\">Live</a>.\nThis project provides a version of websites like pastebin, or hastebin, except without\na central server to store the files; instead users send the files to eachother\nvia <a href=\"https://webtorrent.io/\">webtorrent</a>. <em>Elm</em> is used for the main\nUI components, and <em>Javascript</em> to glue this code with the webtorrent part.</p>\n<!--more-->","frontmatter":{"title":"Peerbin","description":"Peer to Peer Code Sharing","tech":["Elm","Javascript","Webtorrent"],"link":"https://github.com/cronokirby/peerbin","image":"/projects/peerbin.png"}}},{"node":{"id":"6f120704-031a-5518-a4c3-8f052a1a07d6","html":"<p><strong>Hax</strong> is a bullet hell game, in the same vein as others like <em>Touhou</em> or <em>Ikaruga</em>.\nThe game is written in Haskell, using SDL for handling the drawing logic. The game\nlogic benefits greatly from the use of an entity component system for handling the many entities\nin the game. <a href=\"https://hackage.haskell.org/package/apecs\">Apecs</a> was used to provide the scaffolding\nfor this ECS.</p>\n<!--more-->","frontmatter":{"title":"Hax","description":"Bullet Hell Game","tech":["Haskell","SDL"],"link":"https://github.com/cronokirby/hax","image":"/projects/hax.png"}}},{"node":{"id":"f5ae78c8-ab0f-5db9-a8ab-2998fc3de963","html":"<p><strong>Ludus</strong> is an emulator for the NES console, written in <em>Rust</em>. The emulator\nfully emulates, the core CPU, as well as the PPU and APU, and thus full video\nand audio. The emulator also supports a handful of mappers / cartridge types, and thus\nmany common games such as Mario or Zelda.</p>\n<!--more-->","frontmatter":{"title":"Ludus","description":"NES Emulator","tech":["Rust"],"link":"https://github.com/cronokirby/ludus-emu","image":"/projects/ludus.png"}}},{"node":{"id":"e06a4528-1100-5613-9592-cdec3f462d06","html":"<p><strong>Alchemy</strong> is a library over the API for the chat application\n<a href=\"http://discordapp.com/\">Discord</a>. The library integrates over Discord's REST\nand Websocket APIs in order to help developers write applications for their chat\nservers. <em>Elixir</em> was used in order to have easy access to the concurrency involved\nin juggling these various resources.</p>\n<!--more-->","frontmatter":{"title":"Alchemy","description":"A Discord Library for Elixir","tech":["Elixir","Concurrency","Rest APIs","Websocket APIs"],"link":"https://github.com/cronokirby/alchemy","image":"/projects/alchemy.png"}}}]}},"pageContext":{}}}