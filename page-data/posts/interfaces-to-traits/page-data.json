{"componentChunkName":"component---src-templates-post-js","path":"/posts/interfaces-to-traits","result":{"data":{"markdownRemark":{"id":"0a80b594-111e-590b-ba6b-fc5425ddeb81","html":"<p>This is a post about how different languages\nhandle the concept of <em>interfaces</em>. We'll go over the classical\n<em>OO</em> way of handling them, with <em>Java</em>, to the more recent\napproaches of languages like <em>Rust</em>, as well as others in between.</p>\n<h1>Why do we want interfaces?</h1>\n<p>The problem interfaces address is <em>polymorphism</em>.\nPolymorphic code can work with different types of things\nin a flexible way. In practice this means functions\nthat can accept different types, and work differently based on those\ntypes.</p>\n<p>For example, we might have a function that can print out results\nto a file or directly to the terminal.</p>\n<p>Polymorphism lets us write more reusable code. One function\ncan operate on many types without having to be rewritten for each of them.</p>\n<p>Functions that use only an interface, instead of all the implementation\ndetails of a type, are easier to understand. For example, instead of\ndepending on all of a file's operations, we only care about using it as another\noutput stream. This allows our functions to worry\nabout less things, and get closer to having a <em>single responsibility</em>.</p>\n<h1>Classical Interfaces</h1>\n<p>Interfaces in Java are a variant of <em>inheritance</em>, so\nlet's look over how that works first.</p>\n<h2>Inheritance</h2>\n<p>Java has <em>classes</em>, and these have <em>methods</em>.\nFor example:</p>\n<pre><code class=\"language-java\">class Rectangle {\n  private int height;\n  private int width;\n\n  public Rectangle(height, width) {\n    this.height = height;\n    this.width = width;\n  }\n\n  public int area() {\n    return height * width;\n  }\n}\n</code></pre>\n<p>This is a class, with two <em>fields</em>, a <em>constructor</em>, and a method\nthat makes use of both of those fields.</p>\n<p>We can create a new <em>instance</em> of this class, and call its methods\nas follows:</p>\n<pre><code class=\"language-java\">var rectangle = new Rectangle(3, 4);\nSystem.out.println(rectangle.area());\n</code></pre>\n<p>This program prints out <code>12</code>, because we call this rectangle's methods using\nthe data contained in its fields.</p>\n<p>We can also make new classes which inherit from another;\nfor example:</p>\n<pre><code class=\"language-java\">class Square extends Rectangle {\n  public Square(width) {\n    super(width, width);\n  }\n}\n</code></pre>\n<p>This class can be used like this:</p>\n<pre><code class=\"language-java\">var square = new Square(3);\nSystem.out.println(square.area());\n</code></pre>\n<p>This program prints out <code>9</code>.</p>\n<p>The <code>Square</code> class inherits all the methods and their implementations\nfrom its parent class <code>Rectangle</code>, and can use its parent's constructor.\nThis means that it already has all of <code>Rectangle</code>'s methods and their\nimplementations from the start.</p>\n<p>Classes can also change the implementation of certain methods. This\nis called <em>overriding</em> in Java.</p>\n<pre><code class=\"language-java\">  @Override\n  public int height() {\n    // new behavior\n  }\n</code></pre>\n<h2>Abstract Classes</h2>\n<p>Java also has a feature called <em>abstract classes</em>.</p>\n<p>Abstract classes have one big difference from normal classes:\nthey can choose not to provide an implementation for a given method.</p>\n<p>For example:</p>\n<pre><code class=\"language-java\">abstract class Shape {\n  abstract int height();\n\n  int heightSquared() {\n    var h = height();\n    return h * h;\n  }\n}\n</code></pre>\n<p>We've left the <code>height</code> method abstract. We can't actually create\ninstances of the <code>Shape</code> class. Instead, we need to extend the class\nwith another, and then we can create instances of that <em>subclass</em>.</p>\n<h2>Interfaces</h2>\n<p>Now that we've seen classes, and then abstract classes, we\ncan move on to interfaces, as implemented in Java.</p>\n<p>An interface is essentially an abstract class, where\nall the methods are abstract.</p>\n<p>For example:</p>\n<pre><code class=\"language-java\">interface ShapeLike {\n  int area();\n}\n</code></pre>\n<p>We can then have different classes that implement this interface:</p>\n<pre><code class=\"language-java\">class Rectangle implements ShapeLike {\n  int area() {\n    return width * height;\n  }\n}\n\nclass Square implements ShapeLike {\n  int area() {\n    return width * width;\n  }\n}\n</code></pre>\n<p>This can be used for polymorphism, by declaring a function that accepts\nan interface instead of a specific type:</p>\n<pre><code class=\"language-java\">class ShapeUtils {\n   static int areaSquared(ShapeLike shape) {\n     var a = shape.area();\n     return a * a;\n   }\n}\n</code></pre>\n<p>(We make a class with a <em>static</em> method because Java doesn't like free functions).</p>\n<p>One key thing to notice here is that each class has to explicitly\ndeclare that it implements a given interface. There's no way to make\nan old class implement a new interface.</p>\n<p>Java has many other ways of implementing polymorphism through\ninheritence, from subclassing to abstract classes to interfaces.\nAll of these have allow a function to accept a given\ntype without knowing whether that argument is of that exact type,\nor a given subtype. When accepting an interface, a function can only use\nthe methods that interface provides, and is oblivious to the other details the\nvarious classes implementing that interface may have.</p>\n<h1>Middle Ground: Go</h1>\n<p>The main difference between <em>Go</em> and Java is that in Go, implementing\nan interface is implicit, whereas in Java, this is explicit.</p>\n<p>Continuing with our geometry examples, in Go we might have code\nthat looks like this:</p>\n<pre><code class=\"language-go\">package main\n\nimport \"fmt\"\n\ntype Shape interface {\n  area() int\n}\n\ntype Square struct {\n  width int\n}\n\nfunc (s Square) area() int {\n  return s.width * s.width\n}\n\nfunc main() {\n  var s Shape\n  s = Square{width: 3}\n  fmt.Println(s.area())\n}\n</code></pre>\n<p>(This is actually a complete Go program that can be run, and prints out <code>9</code>)</p>\n<p>The first part of this program declares a new interface type, named <code>Shape</code>.\nThis interface is defined by the method <code>area</code>. With the way interfaces\nwork in Go, any type that has a method named <code>area</code> with the right type signature\ncan be used as that interface. Later on in the program, we assign a value\nof type <code>Square</code> to a variable of type <code>Shape</code>. This is allowed because\n<code>Square</code> has a method with the right name and types.</p>\n<p>One downside of Java's interfaces is that old types cannot implement\nnew interfaces. If we notice a behavior we want to abstract over,\nwe can't make it work with existing types. Because Go has implicit interfaces,\nif we notice that multiple types already have a given method, we can abstract\nover that. We can create a function that accepts any type that has a given set\nof methods by using interfaces.</p>\n<h1>Rust's Traits</h1>\n<p>Rust's version of interfaces is called <em>traits</em>. These\ntraits function quite similarly to <em>Haskell</em>'s <em>typeclasses</em>.</p>\n<p>The main difference between Rust and the other two examples\nwe've seen so far is that in Rust, traits are implemented\nexplicitly, but can be implemented for existing types.</p>\n<p>Let's look at an example:</p>\n<pre><code class=\"language-rust\">trait Shape {\n  fn area(&#x26;self) -> i32;\n}\n\nstruct Square {\n  width: i32\n}\n\nimpl Shape for Square {\n   fn area(&#x26;self) -> i32 {\n     width * width\n   }\n}\n</code></pre>\n<p>We've seen a similar example a few times. This is very similar\nto the Go version, except that instead of implementing\nan <code>area</code> method in the struct (which we can do in Rust), and\nthen having the interface implementation be implicit, we have\nto explicitly implement that interface.</p>\n<p>One advantage of explicit implementation is that the Rust\ncompiler can warn us if we incorrectly implement an interface.\nIn Java a similar thing happens as well.</p>\n<p>Because the implementation block is separate from the declaration\nof the type itself, we can implement a trait for a type that already\nexists. This is very useful, because we can identify abstractions at any time.</p>\n<p>There are two \"guidelines\" of sorts that constrain this a little bit.\nWe should try and put a trait implementation either</p>\n<ul>\n<li>In the same file as the declaration of a <em>trait</em></li>\n<li>In the same file as the declaration of a <em>type</em></li>\n</ul>\n<p>For existing types, we have to put the implementation next\nto the trait, since we don't have access to the original file.</p>\n<p>For types we think up after having created the interface, we can\nimplement that interface next to the type.</p>\n<h1>Interface Matrix</h1>\n<p>We can divide up the design space we've gone over so far like so:</p>\n<table>\n<thead>\n<tr>\n<th>Language</th>\n<th>Existing Types</th>\n<th>Explicit</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Java</td>\n<td>No</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td>Go</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Rust</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr>\n</tbody>\n</table>\n<p>I don't know of a language with some kind of interface construct\nwhich doesn't work with existing types, but has implicit implementation.\nI think that this may not even be possible. If the implementation is\nimplicit, then it will pick up the methods that already\nexist for certain types.</p>\n<h1>My Opinions</h1>\n<p>Now we come to the meat of the post: why I think Rust's position\nin the design space is the best.</p>\n<h3>Traits work with existing types</h3>\n<p>This is the most important aspect of traits in my view.</p>\n<p>By being able to implement new traits for old types,\nyou can discover and work on abstractions independently\nof other types. This allows you to work much more flexibly\nwith other people's code, since you can implement\nyour own abstraction layer without having to write a\nbunch of wrapper types.</p>\n<h3>Traits are still explicit</h3>\n<p>In general, I prefer explicit behavior to implicit\nbehavior.</p>\n<p>One advantage of trait implementations being explicit\nis that it's easy to tell that a type implements a trait\ncorrectly. In Rust, if your implementation uses the wrong\nname or method type, then you'll catch it then and there.\nIn Go, you'll only catch this once you try and assign\nthis type to a given interface.</p>\n<p>The two guidelines for where trait implementations\nshould lie keeps things much more orderly. It's very easy\nto know what existing types a trait decided to provide\nimplementations for, since they all have to be located\nnext to the trait itself.</p>\n<h1>Summary</h1>\n<p>Different languages have different ways of implementing\ninterface-like concepts. The main axes in the design space\nare explicit vs implicit implementation, and working\nwith existing types or not.</p>\n<p>Rust's position of working with existing types in an explicit\nway is the best, in my opinion.</p>","frontmatter":{"date":"August 17, 2019","image":"/print8.jpg","path":"/posts/interfaces-to-traits","title":"From Interfaces to Traits","description":"What makes the concept of traits different from interfaces? Why would you want traits in the first place?"}}},"pageContext":{}}}