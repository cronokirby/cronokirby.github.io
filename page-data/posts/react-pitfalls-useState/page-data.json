{"componentChunkName":"component---src-templates-post-js","path":"/posts/react-pitfalls-useState","result":{"data":{"markdownRemark":{"id":"6583f9d3-943c-5c2c-b14e-84e45e1bca03","html":"<h1>Summary</h1>\n<p>This is a quick post about a \"gotcha\" I encountered recently in a React application.\nThis involved the use of React's <code>useState</code> hook, which had a subtle difference\nbetween how I thought the hook worked, and how it actually worked.</p>\n<h1>React Hooks</h1>\n<p>If you're already familiar with hooks in React, feel free to skip this section. This\nis just a recap for those out of the loop.</p>\n<p>Although the first real framework I worked with was <em>Vue</em> (I don't count the one application\nI built with JQuery as having used a framework), I've been using <em>React</em> a ton lately, and\nit's really been growing on me. There's a lot of advantages to being the \"top dog\" in the\nframework game, and React's popularity gives you access to a large ecosystem, and great\npatterns for working on frontend applications.</p>\n<p>One thing I really like about React is the recent \"hooks\" feature.</p>\n<p>Previously, react distinguished between <em>function</em> components, which took in some parameters,\ncalled <em>props</em>, and returned some HTML to be rendered, e.g.</p>\n<pre><code>function TitleCard({ name }) {\n  return &#x3C;p>Hi my name is {name}&#x3C;/p>;\n}\n</code></pre>\n<p>You also had <em>class</em> components, which at first resemble <em>function</em> components:</p>\n<pre><code>class TitleCard extends React.Component {\n  render() {\n    return &#x3C;p>Hi my name is {this.props.name}&#x3C;/p>;\n  }\n}\n</code></pre>\n<p>But class components also have a lot of other features in addition to just rendering some data.\nNotably, they have access to state:</p>\n<pre><code>class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {count: 0};\n  }\n\n  render() {\n    return (\n      &#x3C;div>\n        &#x3C;p>{this.state.count}&#x3C;/p>\n        &#x3C;button onClick={() => this.state.count++}>+&#x3C;/button>\n      &#x3C;/div>\n    );\n  }\n}\n</code></pre>\n<p>This component will render a count, and clicking on the button inside that component will increment\nthe state of that component.</p>\n<p>Having a clear way to use state, and other effects like network requests, etc was something missing\nfrom function components. That's where hooks come in. Hooks, in brief, allow you to use\nthese things in function components.</p>\n<p>For example, if we wanted to take our <code>Counter</code> component from the previous example\nusing a function component with hooks, it'd look like this:</p>\n<pre><code>function Counter() {\n  const [count, setCount] = React.useState(0);\n  return (\n    &#x3C;div>\n      &#x3C;p>{count}&#x3C;/p>\n      &#x3C;button onClick={() => setCount(c => c + 1)}>+&#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>The hook provides us with two values: <code>count</code>, and <code>setCount</code>. The idea is that\n<code>count</code> always holds the current value of the state, and <code>setCount</code> allows us to change\nthis value. The cool thing is that React will always \"do the right thing\" and magically\nupdate this value and rerender the component if necessary. Neat!</p>\n<h1>Rerendering</h1>\n<p>One of the core principles when working with React is that the framework strives\nto make sure that the values a component logically has is always reflected on screen.\nThis means that if some value changes, because of a hook, or because one of the props changed,\nthen a rerender needs to happen to make sure that what's on screen matches what's \"in the code\".</p>\n<p>For example, let's split our counter in two:</p>\n<pre><code>function ShowCounter({ count, setCount }) {\n  return (\n    &#x3C;div>\n      &#x3C;p>{count}&#x3C;/p>\n      &#x3C;button onClick={() => setCount(c => c + 1)}>+&#x3C;/button>\n    &#x3C;/div>\n  );\n}\n\nfunction Counter() {\n  const [count, setCount] = React.useState(0);\n  return &#x3C;ShowCounter {...{count, setCount}}/>\n}\n</code></pre>\n<p>Now the <code>Counter</code> component is the one actually holding the state, and the <code>ShowCounter</code> component\nis just a simple function that shows the data given to it. In order to make sure that the user is\nalways seeing the actual value of the counter, React has to rerender the <code>ShowCounter</code> component\nwhenever the count passed to it changes value.</p>\n<p>This means that React will end up executing the code of the <code>ShowCounter</code> function again. This\nis why its important to avoid firing off network requests without <code>useEffect</code> inside\na function component, because you only want to do certain effects when they need to be run,\nand not just when the component frivously rerenders.</p>\n<h1>State is initialised only once</h1>\n<p>Now we come to the main pitfall I want to talk about in this post.</p>\n<p>Let's allow the user set a value for the counter:</p>\n<pre><code>function Counter({ initial }) {\n  const [count, setCount] = React.useState(initial);\n  return &#x3C;ShowCounter {...{count, setCount}}>;\n}\n</code></pre>\n<p>Based on our previous model, if <code>initial</code> changes, then the component has to rerender,\nand so <code>useState</code> gets called with <code>initial</code>, and so the count becomes <code>initial</code>, right?</p>\n<p>Well it turns out that that's not what happens. In fact with the way <code>useState</code> works,\nthe initial value matters only <strong>the first time a component renders</strong>. After that, it will\npreserve the state between renders.</p>\n<p>This means that we need to do this instead:</p>\n<pre><code>function Counter({ initial }) {\n  const [count, setCount] = React.useState(0);\n  React.useEffect(() => setCount(initial), [initial]);\n  return &#x3C;ShowCounter {...{count, setCount}}>;\n}\n</code></pre>\n<p>We haven't gone over the <code>useEffect</code> hook in detail, but the way it works is that it executes\nthe callback function only if the values inside the array have changed. So here it will set the counter\nto an initial value, but only when the initial value changes. This is the correct way to do\nsomething like this.</p>\n<p>Basically, to avoid this pitfall, <strong>you never want to have anything dynamic inside the call to useState</strong>.</p>\n<h1>Why is this the case?</h1>\n<p>Well, remember how we went over how React \"tries to do the right thing\". Well, it turns out that\nby doing things this way, you actually preserve state between rerenders, which is generally the behavior you want.</p>\n<p>For example, let's say we had something like this:</p>\n<pre><code>function Counter({ name }) {\n  const [count, setCount] = React.useState(0);\n  return (\n    &#x3C;div>\n      &#x3C;p>{name}&#x3C;/p>\n      &#x3C;p>{count}&#x3C;/p>\n      &#x3C;button onClick={() => setCount(c => c + 1)}>+&#x3C;/button>\n    &#x3C;/div>\n  );\n}\n</code></pre>\n<p>Now we're showing a name in addition to the value of the count. We want to rerender if the count or the name\nchanges, since we want the user to see what the current value actually is, but we don't want the count to be\nlost just because the name changed. That's why it makes sense for <code>useState</code> to preserve the\nstate between rerenders.</p>\n<p>It'd require a lot more code to create the behavior of preserving state between rerenders if\nit didn't work that way, but it didn't take much effort with <code>useEffect</code> to do what we wanted\nin the other case. You generally want to try and make the more common use case easy\nwith frameworks, don't you.</p>\n<h2>Further Reading</h2>\n<p><a href=\"https://reactjs.org/docs/hooks-intro.html\">React Hooks</a></p>","frontmatter":{"date":"January 09, 2020","image":"/print1.jpg","path":"/posts/react-pitfalls-useState","title":"React Pitfalls: useState initialization","description":"A common pitfall in React is to initialize useState with a dynamic value, this leads to a bunch of weird bugs"}}},"pageContext":{}}}