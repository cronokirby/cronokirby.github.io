{"componentChunkName":"component---src-templates-post-js","path":"/posts/against-fullstack-data-sharing","result":{"data":{"markdownRemark":{"id":"aa3be166-daa5-5fd5-a83b-c5a7820139ee","html":"<p>This is a post about how I work with data in fullstack development. Specifically, I share what I think are\ngood patterns for sharing data and logic between the frontend and the backend of an application.</p>\n<p>Initially, I was for sharing a lot of logic, classes, and data formats between a frontend and backend\nwritten in the same language, but I've come to change my mind after trying it out on a real project.</p>\n<h1>Fullstack what now?</h1>\n<p>As the title indicates, I'm against <em>Fullstack Data Sharing</em>, but what exactly do I mean by that?\nI struggled to summarize the idea in a few words for the title, so let me give a more detailed\nexplanation of what I mean.</p>\n<p>I like building apps on the web, using Javascript. Or rather, Typescript, but the process and libraries\nare the same. One advantage of JS is that you can have the same language for the backend and\nfrontend of your application. The backend is the code that you, the developer, are responsible for\nrunning, and the frontend is what you send to the users of your application. The backend code is\nusually run on some kind of server, and most of its work centers around a database. The frontend\npresents the functionality of the backend in a nice package for the user.</p>\n<p>Anyways, you need to <em>do things</em> on both sides, and you always have common data between the sides.\nFor example, if I'm making a twitter clone, the concept of a \"Tweet\" exists on both the backend,\nand the frontend. The backend will need to create and retrieve Tweets using the database,\nand the frontend will need to display Tweets to the user, allow them to create Tweets, etc.\nYou need code to handle and manipulate this data on both sides, as well as ways to transfer\nthings between both sides.</p>\n<h2>At least 2 serialization formats</h2>\n<p>Let's focus a little bit on <em>serialization</em>: transforming your code's representation of data\ninto something that can be sent over the wire, or stored in a database. </p>\n<p>There are 2 main places you need to serialize your data in a web application:</p>\n<ul>\n<li>Moving data into the database</li>\n<li>Moving data between the backend and the frontend</li>\n</ul>\n<h3>JSON on the pipes</h3>\n<p>For moving data between the backend and the frontend, in 2020 the ubiquitous format is JSON. If it\nwere 2004, maybe I'd be saying XML instead, but those days are past us. Regardless of how you're\ncommunicating with the backend, be it with GraphQL, REST, gRPC, or something else, you'll be using\nJSON, or something like it.</p>\n<p>JSON has maps, strings and lists, which can be used as the basic building blocks for pretty much\nanything:</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"post\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"data\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"created-at\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"2020-02-12\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"message\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Hello World!\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token property\">\"replies\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"23424234\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"3234234234\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This is an example of a JSON structure, and it showcases how we can represent a lot of nifty things\nwith a relatively simple format. JSON is sufficient to represent a lot of our data structures.</p>\n<p>Another advantage of JSON with JS, is that we can directly serialize (simple) JS objects to JSON:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// {\"foo\": \"bar\"}</span>\n<span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>foo<span class=\"token operator\">:</span> <span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>there are some caveats with this approach I'll get into a bit later, but for now we'll put a tick\nin the \"advantages\" column.</p>\n<h3>ORMs in the back</h3>\n<p>So JSON's got us covered for sending things to the frontend, but what about communication between\nthe backend and our database? Well, this is where ORMs (usually) come in.</p>\n<p>Essentially, an ORM (Object Relational Mapping) wraps the communication between our backend\nand our database, by organizing  the functionality we need from our database around the <em>objects</em> in\nour application.</p>\n<p>For example, instead of directly writing the SQL to create a Tweet, we'd have a Tweet <em>class</em>, with\na method to create a new Tweet as part of the class. We've moved the logic needed to interact\nwith the database into the objects we work with themselves.</p>\n<p>Examples of ORMs in Typescript-land include:</p>\n<ul>\n<li><a href=\"https://mongoosejs.com/\">Mongoose</a> for MongoDB</li>\n<li><a href=\"https://typeorm.io\">TypeORM</a> for SQL like databases</li>\n</ul>\n<p>For every sentence I could write about ORMs here, there's about 10 blog posts debating their merits;\nI won't go into that here. Those blog posts do a much better job of illustrating the pros and cons\nthan I ever could in this post.</p>\n<p>Now, what I do want to highlight about ORMs is that they impose at least one representation of data\nonto you. Before having a database, I might have worked with Tweets using one class, or representation,\nbut if I want to now use TypeORM (for example), then I need to introduce a new representation\nof Tweets, or tailor the existing one to much how TypeORM needs things to be.</p>\n<p>Let's take one of the examples on TypeORM's homepage:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">@<span class=\"token function\">Entity</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n    @<span class=\"token function\">PrimaryGeneratedColumn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    id<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n\n    @<span class=\"token function\">Column</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    firstName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n\n    @<span class=\"token function\">Column</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    lastName<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n\n    @<span class=\"token function\">Column</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    age<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>TypeORM requires us to create a <em>Model</em>, as they call it, which is the representation TypeORM prefers\nfor our data. Now, this library isn't being arbitrary in requiring us to annotate our class like this.\nThe reason TypeORM requires us to have <code class=\"language-text\">@Column</code> and <code class=\"language-text\">@PrimaryGeneratedColumn</code> annotations is\nbecause it uses this to figure out how our Model maps onto our database.</p>\n<p>When you use an ORM, you move the database-friendly representation of your data from the database\nitself, into your application. In exchange, you don't need to convert from your application's\nrepresentation into your database's.</p>\n<p>Without an ORM, you'd have the database's view of things, as defined by how your table is defined\nin SQL, say:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token keyword\">User</span> <span class=\"token punctuation\">(</span>\n    id <span class=\"token keyword\">int</span> <span class=\"token keyword\">primary</span> <span class=\"token keyword\">key</span><span class=\"token punctuation\">,</span>\n    firstName <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">255</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    lastName <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">255</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    age <span class=\"token keyword\">int</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>and then you'd have to write code to convert from what your application has defined a User to be,\ninto what the SQl says.</p>\n<p>With an ORM, you have to define what a User is based on what your ORM requires, but it takes care\nof the database for you.</p>\n<h3>No ORM?</h3>\n<p>If you don't use an ORM, you still have a serialization format, since you need to convert your data\ninto something that the database can use, either by writing some SQL, in the case of a relational\ndatabase, or massaging it into the right document format, for the hip and cool NoSQL document\ndatabases.</p>\n<h2>Sharing in this Context</h2>\n<p>So you have some representation of your entity / concept in your application, be it in the form\nof a class, an ORM model, an interface, a comment, etc. What I mean by sharing, is literally having\nthe code that defines this be used both in the backend of the application, and the frontend of\nthe application.</p>\n<p>For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token comment\">// shared/tweet.ts</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Tweet</span> <span class=\"token punctuation\">{</span>\n  id<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  content<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n  authorID<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>And then <code class=\"language-text\">frontend/showtweet.ts</code> imports this file, and so does <code class=\"language-text\">backend/createtweet.ts</code>. So now\nthis code is shared between both the frontend and the backend.</p>\n<h3>Advantages</h3>\n<p>This approach does have its merits, and at first I thought it was good as well. The main advantage\nhere is respecting the \"Don't Repeat Yourself\" principle.</p>\n<p>A commonly heard mantra in programming is <strong>DRY</strong>, and using the same representation of data\non both the backend and the frontend is definitely respecting DRY, at least literally.\nThe alternative does involve repeating what you mean by a <em>Tweet</em>, or having two slightly\ndifferent concepts of a <em>Tweet</em>. This repetition can lead to problems if the two occurrences\ngrow out of sync.</p>\n<h3>Disadvantages</h3>\n<p>The rest of this post is dedicated to explaining the disadvantages of sharing your data representations\nverbatim between the frontend and the backend. I think there are enough disadvantages to warrant\navoiding this approach (at least in most cases), but I already announced that in the title, didn't I?</p>\n<h1>Sharing your ORM model is \"fun\"</h1>\n<p>(And by \"fun\", I mean \"painful\", as usual)</p>\n<p>The biggest issue with sharing your ORM model directly, at least with the ORMs I know of, is that\nthe ORM depends on the database. More specifically, an ORM library is going to have a dependency\non the database driver it wraps. The database driver is the library that provides a slight\nabstraction over the network protocol the database communicates with. The database driver is probably\nnot something you want to be shipping to your user.</p>\n<p>There's a common complaint going around that our applications, and especially those in the NPM\necosystem, have gotten a bit too dependency-hungry. We have millions of dependencies, 8 layers deep,\nand we can't stop adding more of them to our projects.</p>\n<p>Illustrated:</p>\n<p><img src=\"/node_modules_heavy.png\" alt=\"A diagram shows that .node_modules is heavier than a black hole\"></p>\n<p>One reason for this (I don't think I have the guts to pretend to diagnose the problem), is that\nit's pretty easy to add a new dependency to an application, and hard to feel the costs.</p>\n<p>Well, on the backend you don't feel the costs. On the frontend you actually try to care about\nyour bundle size, at least if you haven't given up hope yet. If your frontend loads quickly\nand your bundle size is manageable, you try and avoid adding big libraries if it's not necessary.\nYou might even take pride in the size of your bundle.</p>\n<p>With that in mind, importing the database driver into your frontend is probably not the best idea.</p>\n<p>If you import the ORM model directly, you're depending on the model, and thus the ORM, and so you\nneed to bundle the database driver in there as well.</p>\n<h2>Workarounds</h2>\n<p>Now, you can avoid bundling the database driver in the frontend, by using some kind of dummy version\nof the annotations the ORM provides, which avoids actually generating the database methods for the model\nyou have.</p>\n<p>The problem with this is that it kind of weakens the promise of sharing code between the backend\nand the frontend. The promise is that with a shared library, you use it just like any other piece of\ncode, on both sides of your application. There's no need for conditional logic or fooling around\nwith advanced settings, it's just code you import directly.</p>\n<p>If you now need to conditionally import a different version of the ORM in your frontend, you're\nweakening the promise a bit. Now it's not as simple as it was before to import the shared code,\nand you wonder if it might have been better to just duplicate a little bit of code instead\nof trying to share those models.</p>\n<h2>The wrong Model?</h2>\n<p>Another problem with using the database's representation in the frontend is a mismatch between\nwhat the frontend uses, and what the database has.</p>\n<p>There might be things in the database that never actually appear in the frontend. There are parts of\nthe database you might not use in <em>this specific</em> frontend application, if it's not the only\nconsumer of your database. There might also be details of you implement your API, such as\n<strong>Join Tables</strong>, which shouldn't show up in your frontend.</p>\n<p>You might also have some parts of the data you send to your frontend be calculated on the fly,\nfor example, counting the number of posts. This count doesn't appear in your ORM model, since it isn't\nin the database, but rather queried on demand. But because you use this count as if it were a field\nin the frontend, you now have a different representation of your data in your frontend.</p>\n<p>If details like these leak through the ORM abstraction you have in the backend, then that's a sign\nthat you probably shouldn't be sharing these models directly with the frontend.</p>\n<h1>Creating a shared class</h1>\n<p>\"Okay, okay, I won't share the ORM model directly with the frontend\"</p>\n<p>Great! But we're not done yet, unfortunately. Let's say you've observed my previous gripes, and\neven agreed with them, so now you separate things in two:</p>\n<p>You have your ORM model, which you use for interacting with the database, and a new representation that\nyou share with both sides. This representation is probably a class, with some methods to do work\non the internal data.</p>\n<h2>Serialization</h2>\n<p>This part is a bit Typescript specific.</p>\n<p>If you have a simple Typescript interface, you can return that very easily from an API endpoint,\nbecause it maps directly to JSON. Most frameworks will provide a way to just \"send\" the object\nitself:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">app<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/endpoint'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">req<span class=\"token punctuation\">,</span> res</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  res<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>woah<span class=\"token operator\">:</span> <span class=\"token string\">'mama'</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>This is real convenient.</p>\n<p>Now, if you have a class, you have a problem. You can't directly send the class as JSON, now you\nneed to write logic to serialize your class to JSON, and logic to parse your class back from the\nJSON on the frontend.</p>\n<p>If you try to just naively <code class=\"language-text\">JSON.stringify</code> it, you'll realize that the methods don't serialize\nand can't be parsed back, so you need to always go through the class constructor on both ends.</p>\n<p>To work around this, you can separate the \"methods\" of your class into functions, and then just\nwork with an interface, but that kind of defeats the point of using a class in the first place.</p>\n<h2>Do you really need to share everything?</h2>\n<p>The serialization problems are more of an inconvenience. The biggest problem I have with this\n\"share\" everything approach, is that you might be sharing things you don't need on the frontend,\nor calculating things on the frontend you could have done in advance.</p>\n<p>For example, some fields that are necessary in the backend might not be needed on the frontend. One\ncommon example is the ubiquitous <code class=\"language-text\">id</code> field, On the backend you're going to be using this one a lot,\nbut on the frontend, you usually don't need the <code class=\"language-text\">id</code> of something, outside of the URL. Having\nto send this each time is a bit of a waste.</p>\n<p>The frontend usually wants <em>the result</em> of a method, and not the logic of method. For example,\nif a user has an array of Tweets as part of their representation, the frontend may want to\nknow the count. They may want just the count, and not even the tweets themselves. This share\neverything approach will send the tweets unnecessarily, and then make the frontend calculate\nthe count iself.</p>\n<p>We could also include the count as part of the backend representation, but this becomes awkward\nif we don't need the count for certain frontend things.</p>\n<h2>Needs aren't uniform across the frontend.</h2>\n<p>We've talked about sharing code in a general sense, but we haven't really talked about the needs\nof a frontend specifically. One aspect of a frontend you might not think about initially is how\nthe needs of your representation change based on which part of the frontend you're at. For example\nif I'm displaying all the posts, I don't need their <em>content</em>, I just need the metadata. I only\nneed everything about the post on the page dedicated to that post.</p>\n<p>If my API always returns everything about the post, that's quite a waste for the main page,\nwhere I'm requesting all posts, but only using a fraction of the data for each post.</p>\n<p>Because of these varying needs, there isn't a single representation of a concept on the frontend.\nRather, there's multiple <em>slices</em> of the same concept, which includes <strong>all</strong> the things you\nmight want to know about some entity. Ideally, you'd share this inclusive concept with the frontend,\nand then allow it select which subset of information it needs for a specific part of the application.</p>\n<h1>What do I advocate then?</h1>\n<p>In one word: <a href=\"https://graphql.org/\"><strong>GraphQL</strong></a>.</p>\n<p>I've been hinting at it in the way I've described certain problems, and certain needs\nthe frontend has. In brief I think your \"shared representation\" should be the GraphQL structure\nyou provide, and the frontend can have as many slices of that representation as it needs. This\nstructure should not mirror the data you store, but rather provide both the data the frontend\nmight need, as well as the calculations it might want to do.</p>\n<p>With GraphQL, you provide all the data and calculations the frontend might want, and then each\npart of the frontend can make requests for exactly the parts they need. This prevents the oversharing\nof unnecessary info, since each part of the frontend can just request the fields it needs.</p>\n<p>This approach also helps avoid duplicate logic, by keeping it in the backend. Since a lot of the\nmethods we had previously have now become GraphQl fields, we no longer share or duplicate the\nlogic in the frontend. Instead, the frontend just sees the logic as if it were a static field,\nwhich simplifies the work your frontend has to do. You can also take advantage of caching, to\navoid recalculating things. Caching class methods is possible, but a lot less convenient.</p>\n<p>You're also free to handle things however you want on the backend. You just need to implement\nyour resolvers. The frontend doesn't need to know which fields are stored in the database,\nwhich are calculated, and what's actually stored in the database. The backend and the frontend\nare now very decoupled, but still share a nice source of truth. GraphQL completely eliminates\nthe problem of serialization across API boundaries, since it will massage things to and from\nJSON for you.</p>\n<h2>User-Centric Graph</h2>\n<p>You also want to avoid providing an all encompassing Graph. Instead, your graph should take a viewpoint\nmore specific to your application. For example, if you have a frontend application where users\ninteract with data specific to them, and don't have access to other user's data, then you should\nprovide a Graph that reflects that reality.</p>\n<p>In this case, you'd have a field for the current user, rather than a field for all users, since\nyour frontend shouldn't be displaying all the users anyways.</p>\n<p>Do:</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Query</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token attr-name\">me</span><span class=\"token punctuation\">:</span> User<span class=\"token operator\">!</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Instead of:</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Query</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token attr-name\">myUserID</span><span class=\"token punctuation\">:</span> ID<span class=\"token operator\">!</span>\n  <span class=\"token attr-name\">user</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$userID</span><span class=\"token punctuation\">:</span> ID<span class=\"token operator\">!</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> User<span class=\"token operator\">!</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This does mean that you may end up with multiple GraphQL endpoints over a single database, which\nis a good thing. You might want to provide one representation optimized for your frontend\napplication, and another for your analytics dashboard. This is normal, since the needs and access\nrestrictions of both applications are very different.</p>\n<h1>Conclusion</h1>\n<p>I think you should make sharing classes and logic between the backend and frontend of your application\nthe exception, and not the the rule. The rule should be to share things by putting them into\nyour GraphQL representation. This representation acts both as a contract / source of truth between\nboth sides, will letting them be sufficiently decoupled.</p>\n<p>Hopefully this post was useful, and I plan to supplement it with an example application, at some point.</p>","frontmatter":{"date":"February 13, 2020","image":"/print14.jpg","path":"/posts/against-fullstack-data-sharing","title":"Against Fullstack Data Sharing","description":"The unintuitive reasons why webapps written in a common language shouldn't share data formats"}}},"pageContext":{}}}