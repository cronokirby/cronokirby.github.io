{"componentChunkName":"component---src-templates-post-js","path":"/posts/poline","result":{"data":{"markdownRemark":{"id":"a18049bc-46f2-5b64-8278-88fb96921c87","html":"<p><em>(Note: this is a first draft)</em></p>\n<p>This is a post about <a href=\"https://github.com/cronokirby/poline\">Poline</a>, a tiny\nprogramming language I wrote recently. The main \"gimmick\" of Poline is\na feature called <em>Green Threads</em>. In fact, Poline doesn't have many other\nfeatures besides them.</p>\n<h1>Green what?</h1>\n<p><a href=\"https://en.wikipedia.org/wiki/Green_threads\">Green Threads</a> are a way of\nmanaging concurrency. The core idea is to have many lightweight threads\nscheduled over fewer OS threads. These tiny threads are then managed by\nthe runtime itself, instead of the OS.</p>\n<h2>Cooperative Scheduling</h2>\n<p>Languages like Go, as well as Poline, do cooperative scheduling for their\nthreads. The runtime knows when a given thread is performing a blocking\noperation, and can \"preempt\" that thread in order to run others. For example,\nwhen a thread is reading from a TCP socket, the runtime can switch off to other\nthreads if no data has arrived yet.</p>\n<h2>Messaging</h2>\n<p>Having independent threads is nice in and of itself, especially when combined\nwith preemption, but threads also want to communicate with eachother.</p>\n<p>In languages like Go, threads must communicate through explicit interfaces\ncalled <em>channels</em>. A channel first needs to be created and then given to\nboth threads before they can communicate to eachother across it. In Go,\nmultiple threads can be sending messages on a channel, and multiple threads\ncan be pulling messages from that channel.</p>\n<p>Other languages, such as Erlang and Poline itself, instead allow communication\nbetween threads directly. In Poline, creating a new thread also gives us a\nhandle, which we can use to send messages to that thread. The thread itself can\nwait until it receives messages sent directly to it.</p>\n<h2>Motivation</h2>\n<p>My main motivation in writing Poline was to learn how to implement Green\nThreading. The impetus was actually a tweet, describing Green Threading as a good interview question.\nI wondered how I might implement that feature myself, and decided to tinker with\ntiny language. Poline doesn't have many features specifically because I wanted\nto focus on this aspect.</p>\n<h1>The language itself</h1>\n<p>Before I go into the implementation of Poline, let's take a look at its syntax.</p>\n<p>A Poline program consists of a series of function declarations.\nHere's an example of one of these declarations:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fn example(arg1, arg2) {\n}</code></pre></div>\n<p>Each function has a name, and then takes a list of named arguments.</p>\n<p>The function called <code class=\"language-text\">main</code>, is the entry point for a program.</p>\n<h2>String litterals</h2>\n<p>The only type of litteral in Poline is the string, which works\nthe same as other languages:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&quot;example string&quot;</code></pre></div>\n<p>The only things a variable can contain in Poline are strings, and thread\nhandles, as we'll see later.</p>\n<h2>Printing</h2>\n<p>Poline has a statement for printing:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fn example(arg) {\n    print arg;\n    print &quot;litteral&quot;;\n}</code></pre></div>\n<p>Both variables, and string litterals can be printed. Every statement\nin poline ends with a semicolon. Every function consists of a series\nof statements.</p>\n<h2>Calling functions</h2>\n<p>Another type of statement is the function call:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fn print(arg) {\n    print arg;\n}\n\nfn main() {\n    print(&quot;foo&quot;);\n}</code></pre></div>\n<p>This works as you'd expect. Extra arguments are ignored, and missing arguments\nare filled in with empty strings.</p>\n<h2>Creating threads</h2>\n<p>Now we come to the real interesting parts of Poline.</p>\n<p>We can create a new thread from a function call:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fn print(arg) {\n    print arg;\n}\n\nfn main() {\n    spawn print(&quot;a&quot;) as p;\n}</code></pre></div>\n<p>Here, the variable <code class=\"language-text\">p</code> contains the handle for the thread we've spawned.\nThe thread will run the function it was called with.</p>\n<h2>Communicating between threads</h2>\n<p>Here's an example program that shows how messaging works:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fn print_recv() {\n    recv arg;\n    print arg;\n}\n\nfn main() {\n    spawn print_recv() as p;\n    send &quot;foo&quot; to p;\n}</code></pre></div>\n<p>After spawning a new thread, we have a handle we can access stored in <code class=\"language-text\">p</code>.\nWe send the string litteral <code class=\"language-text\">&quot;foo&quot;</code> to <code class=\"language-text\">p</code>. We could have sent a variable\ninstead of a string litteral too.</p>\n<p>In the thread <code class=\"language-text\">p</code>, we first receive a message, creating a variable named\n<code class=\"language-text\">arg</code>, and then we print the contents of that variable.</p>\n<h3>Preemption</h3>\n<p>We'll go into the details of this later, but whenever a thread uses <code class=\"language-text\">recv</code>,\nit gets preempted until a message is available. When <code class=\"language-text\">p</code> calls <code class=\"language-text\">recv</code> without\na message to fulfill that request, it gets preempted, letting another\nthread run. Once a message is sent to <code class=\"language-text\">p</code>, it can be considered again.</p>\n<p>Poline is actually deterministic, because it doesn't yet have multithreading.\nIn this case, <code class=\"language-text\">p</code> will always start running after the main thread finishes,\nbecause the main thread has no blocking <code class=\"language-text\">recv</code> calls that preempt it off.</p>\n<h1>Implementation</h1>\n<p>I decided to implement Poline in <em>Rust</em>, mainly because I'm familiar with\nthe language, and because it has good ways of representing ASTs.</p>\n<p>The interpretation pipeline looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Lexing -&gt; Parsing -&gt; Simplifying -&gt; Interpreting</code></pre></div>\n<p>The lexing phase separates the raw text into tokens,\nmaking it easier to parser. The parser converts this newly created\nseries of tokens into an AST representing the program. The simplifier\nmakes the code easier for the interpreter, by doing things like removing\nvariable names. And the interpreter is the work horse here, actually\nexecuting the code.</p>\n<p>I've taken some care in making the code easier to understand, so I encourage\nyou to check out the <a href=\"https://github.com/cronokirby/poline\">source</a>\nitself for more details about the implementation.</p>\n<h2>Lexing</h2>\n<p>The <a href=\"https://github.com/cronokirby/poline/blob/master/src/parser.rs#L62\">lexer</a>\ntakes the raw text of the program, and converts that into\na series of tokens.</p>\n<p>For example, this program:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fn main() {\n    print &quot;foo&quot;;\n}</code></pre></div>\n<p>gets lexed into:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Function Name(&quot;main&quot;) ( ) { Print String(&quot;foo&quot;) ; }</code></pre></div>\n<p>Dealing with a sequence of tokens instead of raw text makes the parser's job much easier.</p>\n<p>The language is simple enough that the lexer can work with just one character of lookahead.\nEssentially, our lexer only needs the following operations from our source of\ntext:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// pseudo code\nfn next(Source) -&gt; Option&lt;char&gt;\nfn peek(Source) -&gt; Option&lt;char&gt;</code></pre></div>\n<p>The first function, <code class=\"language-text\">next</code>, will return <code class=\"language-text\">None</code> if we're at the end of our\nsource, and will otherwise return the next available character, and then advance\nthat source. For example, given <code class=\"language-text\">&quot;12&quot;</code> as our source, the first call to next\nwill return <code class=\"language-text\">Some(&#39;1&#39;)</code>, the next will return <code class=\"language-text\">Some(&#39;2&#39;)</code>, and subsequent calls\nwill return <code class=\"language-text\">None</code>.</p>\n<p>The difference between <code class=\"language-text\">peek</code>, and <code class=\"language-text\">next</code> is that the former doesn't advance the\nsource. Given <code class=\"language-text\">&quot;12&quot;</code> as our input, calls to <code class=\"language-text\">peek</code> will always return <code class=\"language-text\">Some(1)</code>,\nuntil we call <code class=\"language-text\">next</code> to move the input forward.</p>\n<p>The lexer works by repeatedly calling <code class=\"language-text\">next</code>, and then emitting tokens based on\nwhat it says. The one situation where <code class=\"language-text\">peek</code> is needed is parsing names.\nThe lexer keeps interpreting the characters as part of the name until a\nnon-alpha-numeric character is reached with <code class=\"language-text\">peek</code>.</p>\n<p>To handle keywords, the lexer first lexes out a name, and then checks if\nthat name corresponds to one of the built-in keywords. This lets <code class=\"language-text\">printer</code>\nlex as <code class=\"language-text\">Name(&quot;printer&quot;)</code> and not <code class=\"language-text\">print Name(&quot;er&quot;)</code>.</p>\n<h2>Parsing</h2>\n<p>The\n<a href=\"https://github.com/cronokirby/poline/blob/master/src/parser.rs#L219\">parser</a>\ntakes the series of tokens produced by the previous stage, and converts them\ninto a single representation of the program as a <a href=\"https://github.com/cronokirby/poline/blob/master/src/parser.rs#L192\">syntax tree</a>.</p>\n<p>For example, the following program:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fn main() {\n    print &quot;main&quot;;\n    spawn main() as p;\n}</code></pre></div>\n<p>Produces the following tree:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Slightly simplified rust\nSyntax {\n    functions: [\n        FunctionDeclaration {\n            name: &quot;main&quot;,\n            arg_names: [],\n            body: [\n                Statement::Print(Argument::Str(&quot;main&quot;))\n                Statement::Spawn(&quot;p&quot;, FunctionCall {\n                    name: &quot;main&quot;,\n                    args: []\n                })\n            ]\n        }\n    ]\n}</code></pre></div>\n<p>This tree represents the program as presented by the user. The parsing stage\nexcludes programs that make no syntactic sense, e.g.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fn main() main() {\n    print print ; ; &quot;foo&quot;\n}</code></pre></div>\n<p>But it can't do anything for programs that work syntactically, but not logically.</p>\n<p>The parser is written as a hand-crafted\n<a href=\"https://en.wikipedia.org/wiki/Recursive_descent_parser\">recursive descent\nparser</a>,\nbut going into how those work is a bit outside the scope of this post.</p>\n<h1>Simplification</h1>\n<p>To illustrate what\n<a href=\"https://github.com/cronokirby/poline/blob/master/src/simplifier.rs#L355\">simplification</a>\ndoes, let's take the example program from previously:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fn main() {\n    print &quot;main&quot;;\n    spawn main() as p;\n}</code></pre></div>\n<p>This simplifies into:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Program {\n    strings: [&quot;main&quot;],\n    main_function: 0,\n    functions: [FunctionDeclaration {\n       arg_count: 0,\n       body: [\n          Statement::Print(Argument::Str(0)),\n          Statement::Spawn(FunctionCall {\n              name: 0,\n              args: []\n          })\n       ]\n    }]\n}</code></pre></div>\n<p>The first thing to notice is the extra information in addition to the syntax\ntree. We've moved all of the string litterals in our program into an external\ntable, and we have an index for the main function. The main work done by\nsimplification is to remove litteral strings and names from our syntax tree.\nInstead of referring to functions by their name, we refer to them by their\nindex. We now refer to string litterals in the AST by their position in the table.\nVariables are referred to by their position on their stack.</p>\n<h2>Stack indices</h2>\n<p>For variables, we refer to them by stack position. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fn foo(x, y) {\n    print x;\n    print y;\n}</code></pre></div>\n<p>will simplify into:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">FunctionDeclaration {\n    arg_count: 2,\n    body: [\n        Statement::Print(Argument::Name(0)),\n        Statement::Print(Argument::Name(1))\n    ]\n}</code></pre></div>\n<p>Instead of printing <code class=\"language-text\">x</code>, we now print <code class=\"language-text\">0</code>, since we're printing the variable\nwith index <code class=\"language-text\">0</code> on the stack. We'll use a stack to contain the contents of our\nvariables, so all the interpreter needs to do is lookup that position on the stack.</p>\n<h2>Shadowing</h2>\n<p>You might have noticed previously that our spawn statement now takes a single argument\ninstead of two. This is because we refer to variables by their index on the\nstack instead of their name. But spawn always introduces a new variable, even if\nthe name shadows an existing one. Because of this, there's no point having that\nsecond argument, since we always know that spawn pushes to the end of the stack.</p>\n<h1>Interpreter</h1>\n<p>The <a href=\"https://github.com/cronokirby/poline/blob/master/src/interpreter.rs#L387\">interpreter</a>\ntakes the AST produced in the previous steps, and actually runs the code\ncontained inside.</p>\n<h2>Testing</h2>\n<p>The main way I tested the interpreter was by comparing expected print outputs to\nwhat the interpreter actually spit out. In order to test these outputs without\nlooking at a terminal, I used a trait for the effects the interpreter needed:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">pub trait ProgramIO {\n    fn print(&amp;mut self, message: &amp;str);\n}</code></pre></div>\n<p>Instead of printing out directly, the interpreter would instead call this\nmethod. When testing, we pass an implementation of this trait that appends\nprinted messages to a vector. We can inspect this in order to test the interpeter.</p>\n<h2>State</h2>\n<p>The state the interpreter maintains looks something like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">current_thread\nthreads [\n    mailbox\n    calls [\n        function\n        statement_index\n        stack\n    ]\n]</code></pre></div>\n<p>Each thread has a mailbox to contain the messages it receives. The <code class=\"language-text\">send</code>\nstatement results in a new variable being pushed there.</p>\n<p>We also have a sequence of function calls. Everytime a thread calls a function,\nit pushes some new state to the end of these calls. Whenever we reach the end of\na function, we pop that state of from our stack of calls. We also have a stack\ncontaining the variables used in a function. We make sure to keep track of the\nfunction we're executing, along with the index of the statement we're at in that\nfunction, so that we can resume execution after preempting this thread.</p>\n<h2>Structure</h2>\n<p>The way the interpeter works is by finding the next statement to execute,\nand then changing the state around it based on that statement.</p>\n<p>We first look for a statement in the current thread. If a thread becomes\nblocked, then the subsequent thread becomes the current thread. If a thread\nfinishes executing, then we mark that thread's slot as dead, so that we can\nreuse that space.</p>\n<p>All the magic of green threading happens in this statement searching and current\nthread switching.</p>\n<h1>Further Reading</h1>\n<p>This was a high level overview of how the interpreter for poline works. If you\nwant a more detailed look, I'd recommend looking at the\n<a href=\"https://github.com/cronokirby/poline/\">source code</a> itself.</p>","frontmatter":{"date":"August 31, 2019","image":"/print6.jpg","path":"/posts/poline","title":"Poline","description":"This is a post about [Poline](https://github.com/cronokirby/poline), a tiny programming language I wrote recently."}}},"pageContext":{}}}