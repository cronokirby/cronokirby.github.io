{"componentChunkName":"component---src-templates-post-js","path":"/posts/data-races-vs-race-conditions","result":{"data":{"markdownRemark":{"id":"6e528aff-4ade-54b0-8631-a60ea1e0b565","html":"<p>This is a quick post about the difference between <code class=\"language-text\">Data Races</code> and\n<code class=\"language-text\">Race Conditions</code>, and how data structures or patterns providing freedom\nfrom data races can fail to provide race condition freedom.</p>\n<p>The examples will be given in <code class=\"language-text\">Go</code>, since that's a language with a few\nof the concurrent constructs that come into play here, as well as the language\nthat sparked this blog post in the first place.</p>\n<h2>Data Races</h2>\n<p>I agree almost entirely with\n<a href=\"https://doc.rust-lang.org/nomicon/races.html\">rust's definition of data races</a>.\nUnder this definition, a data race is when one or more threads concurrently\naccess a location in memory / variable, at least one of which is a write,\nand at least one of which is not synchronized with other threads.</p>\n<p>For example, multiple concurrent reads to an unsychronized variable are perfectly\nfine:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">const</span> a <span class=\"token operator\">=</span> <span class=\"token number\">3</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thread B: %d\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thread A: %d\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Even though the order of printing will vary from execution to execution,\nthere are no data races since both threads are merely reading from the data.</p>\n<p>If we now have one of the threads access <code class=\"language-text\">a</code> mutably, we introduce a data race:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    a <span class=\"token operator\">:=</span> <span class=\"token number\">3</span>\n    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        a <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n    <span class=\"token punctuation\">}</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thread A: %d\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We can solve this by introducing a mutex to synchronize access to <code class=\"language-text\">a</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    a <span class=\"token operator\">:=</span> <span class=\"token number\">3</span>\n    <span class=\"token keyword\">var</span> m sync<span class=\"token punctuation\">.</span>Mutex\n    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        m<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        a <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n        m<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    m<span class=\"token punctuation\">.</span><span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thread A: %d\\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n    m<span class=\"token punctuation\">.</span><span class=\"token function\">Unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Both threads are accessing <code class=\"language-text\">a</code> at the same time, and one of them is writing,\nbut since the access is synchronized, this is no longer a data race.</p>\n<h2>Race Conditions</h2>\n<p>Race conditions stem from <code class=\"language-text\">non-determinism</code> in concurrent programs.\nIn theory any observable non-determinism from concurrency could be <em>considered</em>\na race condition, but in practice what constitutes a race condition depends\non what properties we want our program to respect.</p>\n<p>Let's take the following program as an example:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n            fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thread B\"</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n        fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thread A\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We'll see some sort of random interleaving of the two messages:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Thread A\nThread A\nThread B\nThread A\nThread B\nThread B\n...</code></pre></div>\n<p>This could be considered a race condition, if the exact order of the printing\nwas a property we wanted our program to respect. We could use some form of\nsynchronization to enforce that order of printing.</p>\n<p>In practice we wouldn't consider this a race condition even if the execution\nisn't deterministic, because this isn't a property we care about.</p>\n<p>In summary, a race condition is some violation of the properties our program\nshould have arising from the concurrent execution of the program.</p>\n<h2>Race Conditions without Data Races</h2>\n<p>The reason I decided to make this post was a discussion I had recently.\nSomeone was claiming that using Go's channels prevents <em>race conditions</em>\nbecause the operations are always thread safe.</p>\n<p>It is true that Go's channels are free from <em>data races</em>, so long as memory\nisn't shared in other ways. That being, said it's pretty easy to\nwrite a program that has a race condition despite only using channels.</p>\n<p>In this example, we'll have a simple server responding to requests to get\nthe value of an integer, and to set the value of an integer.</p>\n<p>The messages look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> msg <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    id <span class=\"token builtin\">int</span>\n    amount <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We'll use <code class=\"language-text\">0</code> as the id for <code class=\"language-text\">get</code> and <code class=\"language-text\">1</code> as the id for <code class=\"language-text\">set</code>.</p>\n<p>Our server type will look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> server <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  msgs <span class=\"token keyword\">chan</span> msg\n  resps <span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">newServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>server <span class=\"token punctuation\">{</span>\n  msgs <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> msg<span class=\"token punctuation\">)</span>\n  resps <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">chan</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&amp;</span>server<span class=\"token punctuation\">{</span>msgs<span class=\"token punctuation\">,</span> resps<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We have a channel to be able to send and receive messages for the server,\nas well as a channel for the responses to those messages.</p>\n<p>Our server will start in the background with the following function:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">*</span>server<span class=\"token punctuation\">)</span> <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">:=</span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n    m <span class=\"token operator\">:=</span> <span class=\"token operator\">&lt;-</span>s<span class=\"token punctuation\">.</span>msgs<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> m<span class=\"token punctuation\">.</span>id <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n      s<span class=\"token punctuation\">.</span>resps <span class=\"token operator\">&lt;-</span> state\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      state <span class=\"token operator\">=</span> m<span class=\"token punctuation\">.</span>amount\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We respond to get requests by sending back the current state, and to set requests\nby setting the concurrent state. Since only one thread is in control\nof the state, interactions with the server are free from data races.</p>\n<p>The basic operations with our server look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">*</span>server<span class=\"token punctuation\">)</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n  s<span class=\"token punctuation\">.</span>msgs <span class=\"token operator\">&lt;-</span> msg<span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;-</span>s<span class=\"token punctuation\">.</span>resps\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">*</span>server<span class=\"token punctuation\">)</span> <span class=\"token function\">set</span><span class=\"token punctuation\">(</span>amount <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  s<span class=\"token punctuation\">.</span>msgs <span class=\"token operator\">&lt;-</span> msg<span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> amount<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now with those basic operations, we can define the following function:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">*</span>server<span class=\"token punctuation\">)</span> <span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  x <span class=\"token operator\">:=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  s<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This function simply increments the state.</p>\n<p>In our main function, we can do the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  s <span class=\"token operator\">:=</span> <span class=\"token function\">newServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">go</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n      s<span class=\"token punctuation\">.</span><span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This will perform 200 increment operations, leaving the state at 200, as expected.</p>\n<p>But if we start sharing these operations between threads, we'll notice\na race condition:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  s <span class=\"token operator\">:=</span> <span class=\"token function\">newServer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">go</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">go</span> <span class=\"token keyword\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n          s<span class=\"token punctuation\">.</span><span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n      s<span class=\"token punctuation\">.</span><span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>We would expect to see 200, as before, but in practice we'll see a smaller number.\nThis is a race condition. This happens because 2 threads can get the same value\nbefore setting the next one, and then both will set the same value, leading\nto 2 calls to increment only performing a single increment.</p>\n<h2>Simple fixes are not enough</h2>\n<p>What we want is an <em>atomic operation</em>. In this case an atomic increment.\nAn atomic increment would mean that each increment happens as a single step,\nand thus prevent two concurrent increments from only leading to a single\noperation.</p>\n<p>We could add such an operation to our server with an additional message,\nlet's say with id <code class=\"language-text\">2</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> m<span class=\"token punctuation\">.</span>id <span class=\"token operator\">==</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">{</span>\n    state<span class=\"token operator\">++</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The problem is that the following function still wouldn't be atomic:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">*</span>server<span class=\"token punctuation\">)</span> <span class=\"token function\">doubleIncrement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    s<span class=\"token punctuation\">.</span><span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>No matter what set of atomic operations our server provides for its state,\nwe can't simply perform multiple operations in sequence, in an unsynchronized\nmanner, and expect the result to also be atomic.</p>\n<p>The full code for this example can be found here:\n<a href=\"https://play.golang.org/p/995MLEiqIVV\">https://play.golang.org/p/995MLEiqIVV</a></p>\n<h2>Summary</h2>\n<p>Data races should not be conflated with race conditions. Just because\na data structure provides data race free operations, doesn't mean that race conditions\ncan't happen with that data structure. Furthermore, sequencing\natomic operations does not yield an atomic operations.</p>\n<p>Designing concurrent programs without bugs is not trivial, and becomes\neven more complicated once you start working with multiple computers.</p>","frontmatter":{"date":"June 14, 2019","image":"/print7.jpg","path":"/posts/data-races-vs-race-conditions","title":"Data Races vs Race Conditions","description":"The difference between data races and race conditions, illustrated in Go"}}},"pageContext":{}}}