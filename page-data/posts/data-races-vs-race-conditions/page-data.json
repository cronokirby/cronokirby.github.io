{"componentChunkName":"component---src-templates-post-js","path":"/posts/data-races-vs-race-conditions","result":{"data":{"markdownRemark":{"id":"6e528aff-4ade-54b0-8631-a60ea1e0b565","html":"<p>This is a quick post about the difference between <code>Data Races</code> and\n<code>Race Conditions</code>, and how data structures or patterns providing freedom\nfrom data races can fail to provide race condition freedom.</p>\n<p>The examples will be given in <code>Go</code>, since that's a language with a few\nof the concurrent constructs that come into play here, as well as the language\nthat sparked this blog post in the first place.</p>\n<h2>Data Races</h2>\n<p>I agree almost entirely with\n<a href=\"https://doc.rust-lang.org/nomicon/races.html\">rust's definition of data races</a>.\nUnder this definition, a data race is when one or more threads concurrently\naccess a location in memory / variable, at least one of which is a write,\nand at least one of which is not synchronized with other threads.</p>\n<p>For example, multiple concurrent reads to an unsychronized variable are perfectly\nfine:</p>\n<pre><code class=\"language-go\">const a = 3\n\nfunc main() {\n    go func() {\n        fmt.Printf(\"Thread B: %d\\n\", a)\n    }\n    fmt.Printf(\"Thread A: %d\\n\", a)\n}\n</code></pre>\n<p>Even though the order of printing will vary from execution to execution,\nthere are no data races since both threads are merely reading from the data.</p>\n<p>If we now have one of the threads access <code>a</code> mutably, we introduce a data race:</p>\n<pre><code class=\"language-go\">func main() {\n    a := 3\n    go func() {\n        a = 10\n    }\n    fmt.Printf(\"Thread A: %d\\n\", a)\n}\n</code></pre>\n<p>We can solve this by introducing a mutex to synchronize access to <code>a</code>:</p>\n<pre><code class=\"language-go\">func main() {\n    a := 3\n    var m sync.Mutex\n    go func() {\n        m.Lock()\n        a = 10\n        m.Unlock()\n    }\n    m.Lock()\n    fmt.Printf(\"Thread A: %d\\n\", a)\n    m.Unlock()\n}\n</code></pre>\n<p>Both threads are accessing <code>a</code> at the same time, and one of them is writing,\nbut since the access is synchronized, this is no longer a data race.</p>\n<h2>Race Conditions</h2>\n<p>Race conditions stem from <code>non-determinism</code> in concurrent programs.\nIn theory any observable non-determinism from concurrency could be <em>considered</em>\na race condition, but in practice what constitutes a race condition depends\non what properties we want our program to respect.</p>\n<p>Let's take the following program as an example:</p>\n<pre><code class=\"language-go\">func main() {\n    go func() {\n        for {\n            fmt.Println(\"Thread B\")\n        }\n    }\n    for {\n        fmt.Println(\"Thread A\")\n    }\n}\n</code></pre>\n<p>We'll see some sort of random interleaving of the two messages:</p>\n<pre><code>Thread A\nThread A\nThread B\nThread A\nThread B\nThread B\n...\n</code></pre>\n<p>This could be considered a race condition, if the exact order of the printing\nwas a property we wanted our program to respect. We could use some form of\nsynchronization to enforce that order of printing.</p>\n<p>In practice we wouldn't consider this a race condition even if the execution\nisn't deterministic, because this isn't a property we care about.</p>\n<p>In summary, a race condition is some violation of the properties our program\nshould have arising from the concurrent execution of the program.</p>\n<h2>Race Conditions without Data Races</h2>\n<p>The reason I decided to make this post was a discussion I had recently.\nSomeone was claiming that using Go's channels prevents <em>race conditions</em>\nbecause the operations are always thread safe.</p>\n<p>It is true that Go's channels are free from <em>data races</em>, so long as memory\nisn't shared in other ways. That being, said it's pretty easy to\nwrite a program that has a race condition despite only using channels.</p>\n<p>In this example, we'll have a simple server responding to requests to get\nthe value of an integer, and to set the value of an integer.</p>\n<p>The messages look like this:</p>\n<pre><code class=\"language-go\">type msg struct {\n    id int\n    amount int\n}\n</code></pre>\n<p>We'll use <code>0</code> as the id for <code>get</code> and <code>1</code> as the id for <code>set</code>.</p>\n<p>Our server type will look like this:</p>\n<pre><code class=\"language-go\">type server struct {\n  msgs chan msg\n  resps chan int\n}\n\nfunc newServer() *server {\n  msgs := make(chan msg)\n  resps := make(chan int)\n  return &#x26;server{msgs, resps}\n}\n</code></pre>\n<p>We have a channel to be able to send and receive messages for the server,\nas well as a channel for the responses to those messages.</p>\n<p>Our server will start in the background with the following function:</p>\n<pre><code class=\"language-go\">func (s *server) start() {\n  state := 0\n  for {\n    m := &#x3C;-s.msgs;\n    if m.id == 0 {\n      s.resps &#x3C;- state\n    } else {\n      state = m.amount\n    }\n  }\n}\n</code></pre>\n<p>We respond to get requests by sending back the current state, and to set requests\nby setting the concurrent state. Since only one thread is in control\nof the state, interactions with the server are free from data races.</p>\n<p>The basic operations with our server look like this:</p>\n<pre><code class=\"language-go\">func (s *server) get() int {\n  s.msgs &#x3C;- msg{0, 0}\n  return &#x3C;-s.resps\n}\n\nfunc (s *server) set(amount int) {\n  s.msgs &#x3C;- msg{1, amount}\n}\n</code></pre>\n<p>Now with those basic operations, we can define the following function:</p>\n<pre><code class=\"language-go\">func (s *server) increment() {\n  x := s.get()\n  s.set(x + 1)\n}\n</code></pre>\n<p>This function simply increments the state.</p>\n<p>In our main function, we can do the following:</p>\n<pre><code class=\"language-go\">func main() {\n  s := newServer()\n  go s.start()\n  for i := 0; i &#x3C; 200; i++ {\n      s.increment()\n  }\n  fmt.Println(s.get())\n}\n</code></pre>\n<p>This will perform 200 increment operations, leaving the state at 200, as expected.</p>\n<p>But if we start sharing these operations between threads, we'll notice\na race condition:</p>\n<pre><code class=\"language-go\">func main() {\n  s := newServer()\n  go s.start()\n  go func() {\n      for i := 0; i &#x3C; 100; i++ {\n          s.increment()\n      }\n  }\n  for i := 0; i &#x3C; 100; i++ {\n      s.increment()\n  }\n  fmt.Println(s.get())\n}\n</code></pre>\n<p>We would expect to see 200, as before, but in practice we'll see a smaller number.\nThis is a race condition. This happens because 2 threads can get the same value\nbefore setting the next one, and then both will set the same value, leading\nto 2 calls to increment only performing a single increment.</p>\n<h2>Simple fixes are not enough</h2>\n<p>What we want is an <em>atomic operation</em>. In this case an atomic increment.\nAn atomic increment would mean that each increment happens as a single step,\nand thus prevent two concurrent increments from only leading to a single\noperation.</p>\n<p>We could add such an operation to our server with an additional message,\nlet's say with id <code>2</code>:</p>\n<pre><code class=\"language-go\">else if m.id == 2 {\n    state++\n}\n</code></pre>\n<p>The problem is that the following function still wouldn't be atomic:</p>\n<pre><code class=\"language-go\">func (s *server) doubleIncrement() {\n    s.increment()\n    s.increment()\n}\n</code></pre>\n<p>No matter what set of atomic operations our server provides for its state,\nwe can't simply perform multiple operations in sequence, in an unsynchronized\nmanner, and expect the result to also be atomic.</p>\n<p>The full code for this example can be found here:\n<a href=\"https://play.golang.org/p/995MLEiqIVV\">https://play.golang.org/p/995MLEiqIVV</a></p>\n<h2>Summary</h2>\n<p>Data races should not be conflated with race conditions. Just because\na data structure provides data race free operations, doesn't mean that race conditions\ncan't happen with that data structure. Furthermore, sequencing\natomic operations does not yield an atomic operations.</p>\n<p>Designing concurrent programs without bugs is not trivial, and becomes\neven more complicated once you start working with multiple computers.</p>","frontmatter":{"date":"June 14, 2019","image":"/print7.jpg","path":"/posts/data-races-vs-race-conditions","title":"Data Races vs Race Conditions","description":"The difference between data races and race conditions, illustrated in Go"}}},"pageContext":{}}}