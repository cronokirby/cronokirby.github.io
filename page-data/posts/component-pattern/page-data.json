{"componentChunkName":"component---src-templates-post-js","path":"/posts/component-pattern","result":{"data":{"markdownRemark":{"id":"fde45e14-d303-59ca-8770-4d231edfe159","html":"<p>This post details a useful pattern for organizing stateful components in functional code.\nThis post assumes knowledge of <strong>Haskell</strong>, up to <strong>Monad-Transformers</strong>.</p>\n<h2>The Problem</h2>\n<p>The organization of a codebase is important: how the files are the laid out, and how\nthe structures inside those files mesh together. A poorly laid out codebase can be difficult\nto navigate and expand. Poorly laid out code can be hard to understand, and even harder to\nbuild upon.</p>\n<p>A running system will be composed of different components. These components are the different\n\"bundles of functionality\" that make up the behavior of our program. They may or may not have\nanalogues in the codebase itself, but a poorly organized codebase rarely makes for a well organized\nset of components.</p>\n<p>Organization is no less of a concern in <em>Functional Programming</em> than it is in the more common\nforms of programming. In fact, the goals we'd like our codebase and running system to achieve\nare the same for both: Modularity and Extensibility, to list a few. Even in <em>Haskell</em>, real-world\napplications have stateful and effectful components to carry out the duties of a program.</p>\n<p>There is less talk about this organizational aspect of code in the \"functional literature\", but it is\nno less important. I think that this is because the organizational side of things is less unique or interesting\ncompared to other aspects of <em>Functional Programming</em>. Because of this, newcomers can learn a lot about the functional\nparadigm, yet still feel unequipped to work on their own projects.</p>\n<h3>Differences from Imperative languages</h3>\n<p>The main difference in a language like <strong>Haskell</strong> as compared to the more common\nimperative languages, is the push towards pure functions. Pure functions are\na good organizational tool, since they make sure we don't couple functions to surrounding\nstate or effects. Because of this, organizing pure functions doesn't require as much care in terms\nof runtime effects. Our code may be hard to understand because of its bad organization,\nbut it's unlikely to have far reaching side effects.</p>\n<h3>Organising Stateful Components</h3>\n<p>Unfortunately, not all programs can be completely pure. Most programs have at least <em>some</em>\ncomponent that requires an effect of some kind, or needs to keep track of some changing state.</p>\n<p>In <em>Object-Oriented</em> programming, the tool to segregate away effects or state is the <strong>Class</strong>.\nIn hybrid languages, like <strong>F#</strong> or <strong>Scala</strong>, using a class to organize a component like this is a perfectably\nacceptable solution. In <strong>Haskell</strong>, however, we can't use this tool. The tools we can use are the <strong>module</strong> and\nthe <strong>context</strong>.</p>\n<p>Modules allow us to organize code in a way that keeps the non-essential implementation details hidden, but the abstract\ninterface to that module exposed. This is similar to classes, except that the module itself has no state or effects.\nA \"context\" allows us to write functions with access to effects or state. We can then export these functions directly from the module,\nalong with the details of that context, or we can hide that context, as we'll see later. <strong>Haskell</strong> can\nimplement contexts in different ways, but we'll be looking at <a href=\"https://wiki.haskell.org/Monad_Transformers\">monad transformers</a>.</p>\n<h3>The Component Pattern</h3>\n<p>Let's get into the meat of the pattern. The idea is to pair a conceptual component of a system,\nsay, a <em>logger</em>, for example, along with a concrete module, and effect type.</p>\n<p>Let's use our logger example more fully. Our project needs a component\nresponsible for logging things to a file. We can send messages for it a log across a queue,\nand it has a file that it logs to.</p>\n<p>First we'd create a module to contain this, say <code>Logger.hs</code>:</p>\n<pre><code class=\"language-hs\">module Logger () where\n-- imports ommitted\n</code></pre>\n<p>The next step is to define a type that contains all the information the logger needs to run:</p>\n<pre><code class=\"language-hs\">data LoggerInfo = LoggerInfo\n    { loggerQueue :: TBQueue Message\n    , loggerFile  :: FilePath\n    }\n</code></pre>\n<p>Then we create a new effect type, which is just a Reader with access to that information:</p>\n<pre><code class=\"language-hs\">newtype LoggerM a = LoggerM (ReaderT LoggerInfo IO a)\n</code></pre>\n<p>Now inside the module itself, we write the functions we need as <code>LoggerM a</code>, for example:</p>\n<pre><code class=\"language-hs\">latestMessage :: LoggerM Message\n\nlogMessages :: LoggerM ()\n</code></pre>\n<p>We also have a main function that contains all the things a component needs to do, sort of like\na \"main loop\" for that component:</p>\n<pre><code class=\"language-hs\">main :: LoggerM ()\n</code></pre>\n<p>At this point we have the tools to express functions for that component inside the module itself,\nbut no API to interact with the component from outside. We have 2 options for exposing this\ncomponent to the outside world.</p>\n<ul>\n<li>Export <code>LoggerInfo</code> and <code>LoggerM</code>, as well as <code>main</code></li>\n</ul>\n<p>We'd have functions to construct <code>LoggerInfo</code> as well as run <code>LoggerM</code>:</p>\n<pre><code class=\"language-hs\">makeLoggerInfo :: File -> IO LoggerInfo\n\nrunLoggerM :: LoggerM a -> LoggerInfo -> IO a\n</code></pre>\n<ul>\n<li>Completely hide the existence of <code>LoggerInfo</code> and <code>LoggerM</code></li>\n</ul>\n<p>With this choice, we'd only export a function that constructs and runs the main logger computation:</p>\n<pre><code class=\"language-hs\">runLoggerMain :: File -> IO ()\n</code></pre>\n<p>Regardless of which choice we make, we're free to start the logger component in a new thread if we want.\nThis is usually done, because components generally contain independent pieces of state, and spend all their time\ndoing the same thing over and over, rather than acting as a one time task.</p>\n<p>Hiding everything is the preferred choice, as it provides more encapsulation, and a cleaner API.\nUsers of the component can ignore the implementation details of the component completely, and just run a single\nfunction in a new thread after passing it all the prerequisite information.</p>\n<h2>Summary</h2>\n<p>In summary, the component pattern looks something like this:</p>\n<pre><code class=\"language-hs\">module Component (startComponent) where\n\ndata ComponentInfo\n\nnewtype ComponentM a = ComponentM (ReaderT ComponentInfo IO a)\n\nmain :: ComponentM ()\n\nstartComponent :: Dependencies -> IO ()\n</code></pre>\n<p>This isn't the end-all-be-all of organising stateful components of a larger project,\nbut hopefully this is a useful pattern to put in the toolbox :)</p>\n<h2>Further Reading</h2>\n<ul>\n<li><a href=\"https://www.fpcomplete.com/blog/2017/06/readert-design-pattern\">https://www.fpcomplete.com/blog/2017/06/readert-design-pattern</a></li>\n</ul>","frontmatter":{"date":"May 14, 2019","image":"/print11.jpg","path":"/posts/component-pattern","title":"The Component Pattern","description":"A common architectural pattern for organising stateful code"}}},"pageContext":{}}}