{"componentChunkName":"component---src-templates-post-js","path":"/posts/introducing-ludus","result":{"data":{"markdownRemark":{"id":"018e6876-0106-54a9-b70a-cd9b73c07f51","html":"<p>This is a short post about a crate I recently published:\n<a href=\"https://crates.io/crates/ludus\">https://crates.io/crates/ludus</a>. This crate provides the core logic of an NES\nemulator, and can be used to build independent GUI applications.</p>\n<p>Ludus started out as a standalone NES emulator, back in October of 2018.\nAt that point, I had gotten a completely working emulator, aside from\nsome pretty glaring audio issues. I wanted to revisit it at some point, in\norder to fix the audio.</p>\n<p>I recently had time to do so, so I went in and cleaned up the code base a bit,\nand ended up finding the causes of the audio bugs.</p>\n<p>The first thing I did was running\n<a href=\"https://github.com/rust-lang/rust-clippy\">clippy</a>\non the entire codebase, and found quite a few issues. The main issue had\nto do with a clippy warning for up-casts like:</p>\n<pre><code class=\"language-rs\">let x: u8;\nx as u16;\n</code></pre>\n<p>Clippy doesn't like this because it can introduce implicit truncation if\nthe type of <code>x</code> ever grew larger. These types of casts appear very frequently\nthroughout the emulator.</p>\n<p>That being said, clippy actually did find the bugs in the APU causing the audio\nglitches:</p>\n<pre><code class=\"language-rs\">if x &#x26; 040 == 0x40\n</code></pre>\n<p>This code was flagged as being an impossible check, rightly so. There were a handful\nof issues like this in the APU causing weird behavior, fixing all the clippy\nchecks thankfully solved all the audio issues.</p>\n<p>After cleaning up the emulator, and fixing these audio bugs after so long,\nI decided to go ahead and work on one of the mappers I hadn't added yet.\nI added <code>iNES1</code> which is the mapper used for games like\n<code>Zelda</code> and <code>Final Fantasy</code>.</p>\n<p>At that point I wanted to experiment with different audio and video backends,\nalthough I ended up sticking with <a href=\"https://crates.io/crates/minifb\">minifb</a>\nfor video, and <a href=\"https://crates.io/crates/cpal\">cpal</a> for audio.</p>\n<p>To make that easier, I ended up creating traits for the video and audio devices,\nand made the core logic of the emulator depend on traits, instead of the\nconcrete video and audio structs that were needed:</p>\n<pre><code class=\"language-rs\">trait VideoDevice {\n    fn blit_pixels(&#x26;mut self, pixels: &#x26;PixelBuffer)\n}\n\ntrait AudioDevice {\n    fn push_sample(&#x26;mut self, sample: f32)\n}\n</code></pre>\n<p>At that point I realised that the core of the emulator could be split off from\nthe rest of the crate that depended on specific backend logic. The core logic\ncrate doesn't even have any dependencies, which is very nice. It could possibly\nwork with <code>#[no_std]</code> but I haven't looked into that at all.</p>\n<p>The application you can use to play games is available\n<a href=\"https://github.com/cronokirby/ludus-emu\">here</a>.</p>\n<p>The standalone crate can be used to create your own NES emulator applications,\nand is available <a href=\"https://crates.io/crates/ludus\">here</a>.</p>","frontmatter":{"date":"June 13, 2019","image":"/print10.jpg","path":"/posts/introducing-ludus","title":"Introducing Ludus","description":"Introducing Ludus, a little NES emulator I wrote recently, using Rust"}}},"pageContext":{}}}