<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming Languages on ck-blog</title>
    <link>/tags/programming-languages/</link>
    <description>Recent content in Programming Languages on ck-blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 31 Aug 2019 19:18:13 -0400</lastBuildDate>
    
	<atom:link href="/tags/programming-languages/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Poline</title>
      <link>/posts/poline/</link>
      <pubDate>Sat, 31 Aug 2019 19:18:13 -0400</pubDate>
      
      <guid>/posts/poline/</guid>
      <description>(Note: this is a first draft)
This is a post about Poline, a tiny programming language I wrote recently. The main &amp;ldquo;gimmick&amp;rdquo; of Poline is a feature called Green Threads. In fact, Poline doesn&amp;rsquo;t have many other features besides them.
Green what? Green Threads are a way of managing concurrency. The core idea is to have many lightweight threads scheduled over fewer OS threads. These tiny threads are then managed by the runtime itself, instead of the OS.</description>
    </item>
    
    <item>
      <title>From Interfaces to Traits</title>
      <link>/posts/interfaces-to-traits/</link>
      <pubDate>Sat, 17 Aug 2019 08:32:00 -0400</pubDate>
      
      <guid>/posts/interfaces-to-traits/</guid>
      <description>This is a post about how different languages handle the concept of interfaces. We&amp;rsquo;ll go over the classical OO way of handling them, with Java, to the more recent approaches of languages like Rust, as well as others in between.
Why do we want interfaces? The problem interfaces address is polymorphism. Polymorphic code can work with different types of things in a flexible way. In practice this means functions that can accept different types, and work differently based on those types.</description>
    </item>
    
  </channel>
</rss>