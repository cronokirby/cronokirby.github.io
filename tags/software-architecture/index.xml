<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software Architecture on ck-blog</title>
    <link>/tags/software-architecture/</link>
    <description>Recent content in Software Architecture on ck-blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 17 Aug 2019 08:32:00 -0400</lastBuildDate>
    
	<atom:link href="/tags/software-architecture/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>From Interfaces to Traits</title>
      <link>/posts/interfaces-to-traits/</link>
      <pubDate>Sat, 17 Aug 2019 08:32:00 -0400</pubDate>
      
      <guid>/posts/interfaces-to-traits/</guid>
      <description>This is a post about how different languages handle the concept of interfaces. We&amp;rsquo;ll go over the classical OO way of handling them, with Java, to the more recent approaches of languages like Rust, as well as others in between.
Why do we want interfaces? The problem interfaces address is polymorphism. Polymorphic code can work with different types of things in a flexible way. In practice this means functions that can accept different types, and work differently based on those types.</description>
    </item>
    
    <item>
      <title>The Component Pattern</title>
      <link>/posts/component-pattern/</link>
      <pubDate>Tue, 14 May 2019 13:57:24 +0200</pubDate>
      
      <guid>/posts/component-pattern/</guid>
      <description>This post details a useful pattern for organizing stateful components in functional code. This post assumes knowledge of Haskell, up to Monad-Transformers.
The Problem The organization of a codebase is important: how the files are the laid out, and how the structures inside those files mesh together. A poorly laid out codebase can be difficult to navigate and expand. Poorly laid out code can be hard to understand, and even harder to build upon.</description>
    </item>
    
  </channel>
</rss>