<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.3fe17e6daba436929c42.css">/*! normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */html{line-height:1.15;-webkit-text-size-adjust:100%}body{margin:0}h1{font-size:2em;margin:.67em 0}a{background-color:transparent}img{border-style:none}[type=button],[type=reset],[type=submit]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring{outline:1px dotted ButtonText}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}[hidden]{display:none}html{box-sizing:border-box;font-family:sans-serif}*,:after,:before{box-sizing:inherit}h1,h2,p,ul{margin:0}ul{list-style:none;padding:0}html{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;line-height:1.5}*,:after,:before{border:0 solid #e2e8f0}img{border-style:solid}[role=button]{cursor:pointer}h1,h2{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}img,svg{display:block;vertical-align:middle}img{max-width:100%;height:auto}body,html{height:100%;background-color:#63b3ed}.bg-blob-1{background-image:url(/blobs/blob1.svg);background-position:0 0;background-size:cover}.clip-1{clip-path:polygon(50% 0,0 100%,84% 78%)}.behind{z-index:-1}.h-128{height:36rem}.blog-post-content{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-size:1.1em}.blog-post-content p{margin-top:1rem;margin-bottom:1rem}.blog-post-content h1{font-size:2.25rem;font-weight:700}.blog-post-content h2{font-size:1.875rem;font-weight:700}.blog-post-content h3{font-size:1.5rem;font-weight:700}.blog-post-content h4{font-size:1.25rem;font-weight:700}.blog-post-content pre{font-family:Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;box-shadow:inset 0 2px 4px 0 rgba(0,0,0,.06);border-radius:.25rem;background-color:#fff;padding:.5rem .75rem;color:#4a5568}.blog-post-content a,.project a{text-decoration:underline}.blog-post-content ul{margin-left:2rem;margin-right:2rem;list-style-type:circle}.blog-post-content ol{margin-left:2rem;margin-right:2rem;list-style-type:decimal}.bg-white{background-color:#fff}.border-gray-700{border-color:#4a5568}.rounded{border-radius:.25rem}.rounded-lg{border-radius:.5rem}.inline-block{display:inline-block}.flex{display:flex}.flex-col{flex-direction:column}.flex-wrap{flex-wrap:wrap}.flex-wrap-reverse{flex-wrap:wrap-reverse}.items-center{align-items:center}.items-baseline{align-items:baseline}.justify-start{justify-content:flex-start}.justify-center{justify-content:center}.justify-between{justify-content:space-between}.justify-around{justify-content:space-around}.flex-grow{flex-grow:1}.font-sans{font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}.font-bold{font-weight:700}.h-48{height:12rem}.h-64{height:16rem}.my-2{margin-top:.5rem;margin-bottom:.5rem}.mx-2{margin-left:.5rem;margin-right:.5rem}.mx-3{margin-left:.75rem;margin-right:.75rem}.my-4{margin-top:1rem;margin-bottom:1rem}.mx-4{margin-left:1rem;margin-right:1rem}.mx-8{margin-left:2rem;margin-right:2rem}.mx-auto{margin-left:auto;margin-right:auto}.mt-2{margin-top:.5rem}.mr-3{margin-right:.75rem}.mt-4{margin-top:1rem}.mr-4{margin-right:1rem}.mb-4{margin-bottom:1rem}.ml-4{margin-left:1rem}.mt-12{margin-top:3rem}.mt-16{margin-top:4rem}.object-contain{object-fit:contain}.object-cover{object-fit:cover}.object-top{object-position:top}.px-1{padding-left:.25rem;padding-right:.25rem}.py-2{padding-top:.5rem;padding-bottom:.5rem}.px-2{padding-left:.5rem;padding-right:.5rem}.py-4{padding-top:1rem;padding-bottom:1rem}.px-4{padding-left:1rem;padding-right:1rem}.py-6{padding-top:1.5rem;padding-bottom:1.5rem}.absolute{position:absolute}.relative{position:relative}.top-0{top:0}.left-0{left:0}.shadow-md{box-shadow:0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -1px rgba(0,0,0,.06)}.shadow-lg{box-shadow:0 10px 15px -3px rgba(0,0,0,.1),0 4px 6px -2px rgba(0,0,0,.05)}.fill-current{fill:currentColor}.text-white{color:#fff}.text-gray-700{color:#4a5568}.text-gray-800{color:#2d3748}.text-main-600{color:#3182ce}.hover\:text-main-200:hover{color:#bee3f8}.hover\:text-main-600:hover{color:#3182ce}.text-xs{font-size:.75rem}.text-sm{font-size:.875rem}.text-lg{font-size:1.125rem}.text-xl{font-size:1.25rem}.text-2xl{font-size:1.5rem}.text-3xl{font-size:1.875rem}.text-4xl{font-size:2.25rem}.text-6xl{font-size:4rem}.italic{font-style:italic}.hover\:underline:hover,.underline{text-decoration:underline}.visible{visibility:visible}.w-64{width:16rem}.w-3\/4{width:75%}.w-10\/12{width:83.333333%}.w-11\/12{width:91.666667%}.w-full{width:100%}.z-10{z-index:10}@media (min-width:640px){.sm\:justify-start{justify-content:flex-start}.sm\:mx-8{margin-right:2rem}.sm\:ml-8,.sm\:mx-8{margin-left:2rem}.sm\:px-8{padding-left:2rem;padding-right:2rem}.sm\:text-3xl{font-size:1.875rem}.sm\:text-5xl{font-size:3rem}.sm\:w-64{width:16rem}.sm\:w-1\/3{width:33.333333%}.sm\:w-3\/4{width:75%}.sm\:w-5\/6{width:83.333333%}.sm\:w-5\/12{width:41.666667%}}@media (min-width:768px){.md\:mr-8{margin-right:2rem}.md\:mt-24{margin-top:6rem}.md\:mt-32{margin-top:8rem}.md\:text-4xl{font-size:2.25rem}.md\:text-6xl{font-size:4rem}.md\:text-8xl{font-size:6rem}.md\:w-5\/12{width:41.666667%}}@media (min-width:1024px){.lg\:w-1\/2{width:50%}.lg\:w-3\/12{width:25%}.lg\:w-6\/12{width:50%}}code[class*=language-],pre[class*=language-]{color:#657b83;font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}code[class*=language-]::-moz-selection,code[class*=language-] ::-moz-selection,pre[class*=language-]::-moz-selection,pre[class*=language-] ::-moz-selection{background:#073642}code[class*=language-]::selection,code[class*=language-] ::selection,pre[class*=language-]::selection,pre[class*=language-] ::selection{background:#073642}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#93a1a1}.token.punctuation{color:#586e75}.token.namespace{opacity:.7}.token.boolean,.token.constant,.token.deleted,.token.number,.token.property,.token.symbol,.token.tag{color:#268bd2}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string,.token.url{color:#2aa198}.token.entity{color:#657b83}.token.atrule,.token.attr-value,.token.keyword{color:#859900}.token.class-name,.token.function{color:#b58900}.token.important,.token.regex,.token.variable{color:#cb4b16}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}</style><meta name="generator" content="Gatsby 2.19.7"/><link rel="alternate" type="application/rss+xml" href="/rss.xml"/><title data-react-helmet="true">Against Fullstack Data Sharing | Cronokirby</title><meta data-react-helmet="true" name="description" content="The unintuitive reasons why webapps written in a common language shouldn&#x27;t share data formats"/><link as="script" rel="preload" href="/webpack-runtime-b70c3b8306dda07e717b.js"/><link as="script" rel="preload" href="/styles-a307afcb1c8432acadfb.js"/><link as="script" rel="preload" href="/app-91e2c058516df8769a9d.js"/><link as="script" rel="preload" href="/commons-5d8df6b41bcacf3ad498.js"/><link as="script" rel="preload" href="/component---src-templates-post-js-1dc6a74bfbadd02f5f31.js"/><link as="fetch" rel="preload" href="/page-data/posts/against-fullstack-data-sharing/page-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" role="group" id="gatsby-focus-wrapper"><nav><ul class="flex items-baseline justify-around py-2 mx-auto mb-4 text-2xl px-4 sm:text-3xl font-bold text-white sm:w-3/4 lg:w-1/2"><li><a class="mr-4 hover:underline hover:text-main-200 md:mr-8" href="/posts">Posts</a></li><li><a class="hover:underline hover:text-main-200 sm:mx-8" href="/projects">Projects</a></li><li class="flex-grow"></li><li class="hover:text-main-200"><a href="https://github.com/cronokirby"><svg width="32px" height="31px" viewBox="0 0 256 250" version="1.1" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid" class="fill-current"><g><path d="M128.00106,0 C57.3172926,0 0,57.3066942 0,128.00106 C0,184.555281 36.6761997,232.535542 87.534937,249.460899 C93.9320223,250.645779 96.280588,246.684165 96.280588,243.303333 C96.280588,240.251045 96.1618878,230.167899 96.106777,219.472176 C60.4967585,227.215235 52.9826207,204.369712 52.9826207,204.369712 C47.1599584,189.574598 38.770408,185.640538 38.770408,185.640538 C27.1568785,177.696113 39.6458206,177.859325 39.6458206,177.859325 C52.4993419,178.762293 59.267365,191.04987 59.267365,191.04987 C70.6837675,210.618423 89.2115753,204.961093 96.5158685,201.690482 C97.6647155,193.417512 100.981959,187.77078 104.642583,184.574357 C76.211799,181.33766 46.324819,170.362144 46.324819,121.315702 C46.324819,107.340889 51.3250588,95.9223682 59.5132437,86.9583937 C58.1842268,83.7344152 53.8029229,70.715562 60.7532354,53.0843636 C60.7532354,53.0843636 71.5019501,49.6441813 95.9626412,66.2049595 C106.172967,63.368876 117.123047,61.9465949 128.00106,61.8978432 C138.879073,61.9465949 149.837632,63.368876 160.067033,66.2049595 C184.49805,49.6441813 195.231926,53.0843636 195.231926,53.0843636 C202.199197,70.715562 197.815773,83.7344152 196.486756,86.9583937 C204.694018,95.9223682 209.660343,107.340889 209.660343,121.315702 C209.660343,170.478725 179.716133,181.303747 151.213281,184.472614 C155.80443,188.444828 159.895342,196.234518 159.895342,208.176593 C159.895342,225.303317 159.746968,239.087361 159.746968,243.303333 C159.746968,246.709601 162.05102,250.70089 168.53925,249.443941 C219.370432,232.499507 256,184.536204 256,128.00106 C256,57.3066942 198.691187,0 128.00106,0 Z M47.9405593,182.340212 C47.6586465,182.976105 46.6581745,183.166873 45.7467277,182.730227 C44.8183235,182.312656 44.2968914,181.445722 44.5978808,180.80771 C44.8734344,180.152739 45.876026,179.97045 46.8023103,180.409216 C47.7328342,180.826786 48.2627451,181.702199 47.9405593,182.340212 Z M54.2367892,187.958254 C53.6263318,188.524199 52.4329723,188.261363 51.6232682,187.366874 C50.7860088,186.474504 50.6291553,185.281144 51.2480912,184.70672 C51.8776254,184.140775 53.0349512,184.405731 53.8743302,185.298101 C54.7115892,186.201069 54.8748019,187.38595 54.2367892,187.958254 Z M58.5562413,195.146347 C57.7719732,195.691096 56.4895886,195.180261 55.6968417,194.042013 C54.9125733,192.903764 54.9125733,191.538713 55.713799,190.991845 C56.5086651,190.444977 57.7719732,190.936735 58.5753181,192.066505 C59.3574669,193.22383 59.3574669,194.58888 58.5562413,195.146347 Z M65.8613592,203.471174 C65.1597571,204.244846 63.6654083,204.03712 62.5716717,202.981538 C61.4524999,201.94927 61.1409122,200.484596 61.8446341,199.710926 C62.5547146,198.935137 64.0575422,199.15346 65.1597571,200.200564 C66.2704506,201.230712 66.6095936,202.705984 65.8613592,203.471174 Z M75.3025151,206.281542 C74.9930474,207.284134 73.553809,207.739857 72.1039724,207.313809 C70.6562556,206.875043 69.7087748,205.700761 70.0012857,204.687571 C70.302275,203.678621 71.7478721,203.20382 73.2083069,203.659543 C74.6539041,204.09619 75.6035048,205.261994 75.3025151,206.281542 Z M86.046947,207.473627 C86.0829806,208.529209 84.8535871,209.404622 83.3316829,209.4237 C81.8013,209.457614 80.563428,208.603398 80.5464708,207.564772 C80.5464708,206.498591 81.7483088,205.631657 83.2786917,205.606221 C84.8005962,205.576546 86.046947,206.424403 86.046947,207.473627 Z M96.6021471,207.069023 C96.7844366,208.099171 95.7267341,209.156872 94.215428,209.438785 C92.7295577,209.710099 91.3539086,209.074206 91.1652603,208.052538 C90.9808515,206.996955 92.0576306,205.939253 93.5413813,205.66582 C95.054807,205.402984 96.4092596,206.021919 96.6021471,207.069023 Z"></path></g></svg></a></li><li class="ml-4 sm:ml-8 hover:text-main-200"><a href="/rss.xml"><svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="28px" height="28px" viewBox="0 0 430.117 430.118" class="fill-current"><g><path id="RSS" d="M97.493,332.473c10.419,10.408,16.755,24.525,16.794,40.244c-0.04,15.687-6.375,29.809-16.755,40.17l-0.04,0.019 c-10.398,10.352-24.603,16.681-40.398,16.681c-15.775,0-29.944-6.348-40.34-16.699C6.384,402.526,0,388.422,0,372.717 c0-15.719,6.384-29.869,16.754-40.253v0.009c10.401-10.36,24.57-16.735,40.34-16.735C72.89,315.738,87.081,322.131,97.493,332.473z M97.493,332.464v0.009c0.019,0,0.019,0,0.019,0L97.493,332.464z M16.754,412.906c0,0,0,0,0-0.019c-0.019,0-0.019,0-0.019,0 L16.754,412.906z M0.046,146.259v82.129c53.618,0.033,104.328,21.096,142.278,59.104c37.943,37.888,58.917,88.675,59.003,142.477 h0.028v0.149h82.467c-0.065-78.233-31.866-149.099-83.279-200.549C149.122,178.126,78.285,146.308,0.046,146.259z M0.196,0v82.089 c191.661,0.14,347.464,156.184,347.594,348.028h82.327c-0.056-118.571-48.248-225.994-126.132-303.932 C226.073,48.274,118.721,0.051,0.196,0z"></path></g></svg></a></li><li class="ml-4 sm:ml-8 hover:text-main-200"><a href="https://twitter.com/cronokirby"><svg width="32px" height="26px" viewBox="0 0 256 209" version="1.1" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="xMidYMid" class="fill-current"><g><path d="M256,25.4500259 C246.580841,29.6272672 236.458451,32.4504868 225.834156,33.7202333 C236.678503,27.2198053 245.00583,16.9269929 248.927437,4.66307685 C238.779765,10.6812633 227.539325,15.0523376 215.57599,17.408298 C205.994835,7.2006971 192.34506,0.822 177.239197,0.822 C148.232605,0.822 124.716076,24.3375931 124.716076,53.3423116 C124.716076,57.4586875 125.181462,61.4673784 126.076652,65.3112644 C82.4258385,63.1210453 43.7257252,42.211429 17.821398,10.4359288 C13.3005011,18.1929938 10.710443,27.2151234 10.710443,36.8402889 C10.710443,55.061526 19.9835254,71.1374907 34.0762135,80.5557137 C25.4660961,80.2832239 17.3681846,77.9207088 10.2862577,73.9869292 C10.2825122,74.2060448 10.2825122,74.4260967 10.2825122,74.647085 C10.2825122,100.094453 28.3867003,121.322443 52.413563,126.14673 C48.0059695,127.347184 43.3661509,127.988612 38.5755734,127.988612 C35.1914554,127.988612 31.9009766,127.659938 28.694773,127.046602 C35.3777973,147.913145 54.7742053,163.097665 77.7569918,163.52185 C59.7820257,177.607983 37.1354036,186.004604 12.5289147,186.004604 C8.28987161,186.004604 4.10888474,185.75646 0,185.271409 C23.2431033,200.173139 50.8507261,208.867532 80.5109185,208.867532 C177.116529,208.867532 229.943977,128.836982 229.943977,59.4326002 C229.943977,57.1552968 229.893412,54.8901664 229.792282,52.6381454 C240.053257,45.2331635 248.958338,35.9825545 256,25.4500259"></path></g></svg></a></li></ul></nav><div class="px-2 py-2 mx-auto my-4 text-gray-800 bg-white rounded shadow-md sm:w-5/6 lg:w-6/12 object-contain"><img src="/print14.jpg" alt="" class="h-128 mx-auto"/><div class="px-4 py-4 sm:px-8"><h2 class="mt-2 text-xl text-brown-800">February 13, 2020</h2><h1 class="mb-4 text-6xl font-bold">Against Fullstack Data Sharing</h1><div class="blog-post-content"><p>This is a post about how I work with data in fullstack development. Specifically, I share what I think are
good patterns for sharing data and logic between the frontend and the backend of an application.</p>
<p>Initially, I was for sharing a lot of logic, classes, and data formats between a frontend and backend
written in the same language, but I've come to change my mind after trying it out on a real project.</p>
<h1>Fullstack what now?</h1>
<p>As the title indicates, I'm against <em>Fullstack Data Sharing</em>, but what exactly do I mean by that?
I struggled to summarize the idea in a few words for the title, so let me give a more detailed
explanation of what I mean.</p>
<p>I like building apps on the web, using Javascript. Or rather, Typescript, but the process and libraries
are the same. One advantage of JS is that you can have the same language for the backend and
frontend of your application. The backend is the code that you, the developer, are responsible for
running, and the frontend is what you send to the users of your application. The backend code is
usually run on some kind of server, and most of its work centers around a database. The frontend
presents the functionality of the backend in a nice package for the user.</p>
<p>Anyways, you need to <em>do things</em> on both sides, and you always have common data between the sides.
For example, if I'm making a twitter clone, the concept of a "Tweet" exists on both the backend,
and the frontend. The backend will need to create and retrieve Tweets using the database,
and the frontend will need to display Tweets to the user, allow them to create Tweets, etc.
You need code to handle and manipulate this data on both sides, as well as ways to transfer
things between both sides.</p>
<h2>At least 2 serialization formats</h2>
<p>Let's focus a little bit on <em>serialization</em>: transforming your code's representation of data
into something that can be sent over the wire, or stored in a database. </p>
<p>There are 2 main places you need to serialize your data in a web application:</p>
<ul>
<li>Moving data into the database</li>
<li>Moving data between the backend and the frontend</li>
</ul>
<h3>JSON on the pipes</h3>
<p>For moving data between the backend and the frontend, in 2020 the ubiquitous format is JSON. If it
were 2004, maybe I'd be saying XML instead, but those days are past us. Regardless of how you're
communicating with the backend, be it with GraphQL, REST, gRPC, or something else, you'll be using
JSON, or something like it.</p>
<p>JSON has maps, strings and lists, which can be used as the basic building blocks for pretty much
anything:</p>
<div class="gatsby-highlight" data-language="json"><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"post"</span><span class="token punctuation">,</span>
  <span class="token property">"data"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"created-at"</span><span class="token operator">:</span> <span class="token string">"2020-02-12"</span><span class="token punctuation">,</span>
    <span class="token property">"message"</span><span class="token operator">:</span> <span class="token string">"Hello World!"</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
  <span class="token property">"replies"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"23424234"</span><span class="token punctuation">,</span> <span class="token string">"3234234234"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre></div>
<p>This is an example of a JSON structure, and it showcases how we can represent a lot of nifty things
with a relatively simple format. JSON is sufficient to represent a lot of our data structures.</p>
<p>Another advantage of JSON with JS, is that we can directly serialize (simple) JS objects to JSON:</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js"><span class="token comment">// {"foo": "bar"}</span>
<span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{</span>foo<span class="token operator">:</span> <span class="token string">"bar"</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></div>
<p>there are some caveats with this approach I'll get into a bit later, but for now we'll put a tick
in the "advantages" column.</p>
<h3>ORMs in the back</h3>
<p>So JSON's got us covered for sending things to the frontend, but what about communication between
the backend and our database? Well, this is where ORMs (usually) come in.</p>
<p>Essentially, an ORM (Object Relational Mapping) wraps the communication between our backend
and our database, by organizing  the functionality we need from our database around the <em>objects</em> in
our application.</p>
<p>For example, instead of directly writing the SQL to create a Tweet, we'd have a Tweet <em>class</em>, with
a method to create a new Tweet as part of the class. We've moved the logic needed to interact
with the database into the objects we work with themselves.</p>
<p>Examples of ORMs in Typescript-land include:</p>
<ul>
<li><a href="https://mongoosejs.com/">Mongoose</a> for MongoDB</li>
<li><a href="https://typeorm.io">TypeORM</a> for SQL like databases</li>
</ul>
<p>For every sentence I could write about ORMs here, there's about 10 blog posts debating their merits;
I won't go into that here. Those blog posts do a much better job of illustrating the pros and cons
than I ever could in this post.</p>
<p>Now, what I do want to highlight about ORMs is that they impose at least one representation of data
onto you. Before having a database, I might have worked with Tweets using one class, or representation,
but if I want to now use TypeORM (for example), then I need to introduce a new representation
of Tweets, or tailor the existing one to much how TypeORM needs things to be.</p>
<p>Let's take one of the examples on TypeORM's homepage:</p>
<div class="gatsby-highlight" data-language="ts"><pre class="language-ts"><code class="language-ts">@<span class="token function">Entity</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
    @<span class="token function">PrimaryGeneratedColumn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

    @<span class="token function">Column</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    firstName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

    @<span class="token function">Column</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    lastName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

    @<span class="token function">Column</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre></div>
<p>TypeORM requires us to create a <em>Model</em>, as they call it, which is the representation TypeORM prefers
for our data. Now, this library isn't being arbitrary in requiring us to annotate our class like this.
The reason TypeORM requires us to have <code class="language-text">@Column</code> and <code class="language-text">@PrimaryGeneratedColumn</code> annotations is
because it uses this to figure out how our Model maps onto our database.</p>
<p>When you use an ORM, you move the database-friendly representation of your data from the database
itself, into your application. In exchange, you don't need to convert from your application's
representation into your database's.</p>
<p>Without an ORM, you'd have the database's view of things, as defined by how your table is defined
in SQL, say:</p>
<div class="gatsby-highlight" data-language="sql"><pre class="language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">User</span> <span class="token punctuation">(</span>
    id <span class="token keyword">int</span> <span class="token keyword">primary</span> <span class="token keyword">key</span><span class="token punctuation">,</span>
    firstName <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    lastName <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    age <span class="token keyword">int</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></div>
<p>and then you'd have to write code to convert from what your application has defined a User to be,
into what the SQl says.</p>
<p>With an ORM, you have to define what a User is based on what your ORM requires, but it takes care
of the database for you.</p>
<h3>No ORM?</h3>
<p>If you don't use an ORM, you still have a serialization format, since you need to convert your data
into something that the database can use, either by writing some SQL, in the case of a relational
database, or massaging it into the right document format, for the hip and cool NoSQL document
databases.</p>
<h2>Sharing in this Context</h2>
<p>So you have some representation of your entity / concept in your application, be it in the form
of a class, an ORM model, an interface, a comment, etc. What I mean by sharing, is literally having
the code that defines this be used both in the backend of the application, and the frontend of
the application.</p>
<p>For example:</p>
<div class="gatsby-highlight" data-language="typescript"><pre class="language-typescript"><code class="language-typescript"><span class="token comment">// shared/tweet.ts</span>
<span class="token keyword">interface</span> <span class="token class-name">Tweet</span> <span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  content<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  authorID<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span></code></pre></div>
<p>And then <code class="language-text">frontend/showtweet.ts</code> imports this file, and so does <code class="language-text">backend/createtweet.ts</code>. So now
this code is shared between both the frontend and the backend.</p>
<h3>Advantages</h3>
<p>This approach does have its merits, and at first I thought it was good as well. The main advantage
here is respecting the "Don't Repeat Yourself" principle.</p>
<p>A commonly heard mantra in programming is <strong>DRY</strong>, and using the same representation of data
on both the backend and the frontend is definitely respecting DRY, at least literally.
The alternative does involve repeating what you mean by a <em>Tweet</em>, or having two slightly
different concepts of a <em>Tweet</em>. This repetition can lead to problems if the two occurrences
grow out of sync.</p>
<h3>Disadvantages</h3>
<p>The rest of this post is dedicated to explaining the disadvantages of sharing your data representations
verbatim between the frontend and the backend. I think there are enough disadvantages to warrant
avoiding this approach (at least in most cases), but I already announced that in the title, didn't I?</p>
<h1>Sharing your ORM model is "fun"</h1>
<p>(And by "fun", I mean "painful", as usual)</p>
<p>The biggest issue with sharing your ORM model directly, at least with the ORMs I know of, is that
the ORM depends on the database. More specifically, an ORM library is going to have a dependency
on the database driver it wraps. The database driver is the library that provides a slight
abstraction over the network protocol the database communicates with. The database driver is probably
not something you want to be shipping to your user.</p>
<p>There's a common complaint going around that our applications, and especially those in the NPM
ecosystem, have gotten a bit too dependency-hungry. We have millions of dependencies, 8 layers deep,
and we can't stop adding more of them to our projects.</p>
<p>Illustrated:</p>
<p><img src="/node_modules_heavy.png" alt="A diagram shows that .node_modules is heavier than a black hole"></p>
<p>One reason for this (I don't think I have the guts to pretend to diagnose the problem), is that
it's pretty easy to add a new dependency to an application, and hard to feel the costs.</p>
<p>Well, on the backend you don't feel the costs. On the frontend you actually try to care about
your bundle size, at least if you haven't given up hope yet. If your frontend loads quickly
and your bundle size is manageable, you try and avoid adding big libraries if it's not necessary.
You might even take pride in the size of your bundle.</p>
<p>With that in mind, importing the database driver into your frontend is probably not the best idea.</p>
<p>If you import the ORM model directly, you're depending on the model, and thus the ORM, and so you
need to bundle the database driver in there as well.</p>
<h2>Workarounds</h2>
<p>Now, you can avoid bundling the database driver in the frontend, by using some kind of dummy version
of the annotations the ORM provides, which avoids actually generating the database methods for the model
you have.</p>
<p>The problem with this is that it kind of weakens the promise of sharing code between the backend
and the frontend. The promise is that with a shared library, you use it just like any other piece of
code, on both sides of your application. There's no need for conditional logic or fooling around
with advanced settings, it's just code you import directly.</p>
<p>If you now need to conditionally import a different version of the ORM in your frontend, you're
weakening the promise a bit. Now it's not as simple as it was before to import the shared code,
and you wonder if it might have been better to just duplicate a little bit of code instead
of trying to share those models.</p>
<h2>The wrong Model?</h2>
<p>Another problem with using the database's representation in the frontend is a mismatch between
what the frontend uses, and what the database has.</p>
<p>There might be things in the database that never actually appear in the frontend. There are parts of
the database you might not use in <em>this specific</em> frontend application, if it's not the only
consumer of your database. There might also be details of you implement your API, such as
<strong>Join Tables</strong>, which shouldn't show up in your frontend.</p>
<p>You might also have some parts of the data you send to your frontend be calculated on the fly,
for example, counting the number of posts. This count doesn't appear in your ORM model, since it isn't
in the database, but rather queried on demand. But because you use this count as if it were a field
in the frontend, you now have a different representation of your data in your frontend.</p>
<p>If details like these leak through the ORM abstraction you have in the backend, then that's a sign
that you probably shouldn't be sharing these models directly with the frontend.</p>
<h1>Creating a shared class</h1>
<p>"Okay, okay, I won't share the ORM model directly with the frontend"</p>
<p>Great! But we're not done yet, unfortunately. Let's say you've observed my previous gripes, and
even agreed with them, so now you separate things in two:</p>
<p>You have your ORM model, which you use for interacting with the database, and a new representation that
you share with both sides. This representation is probably a class, with some methods to do work
on the internal data.</p>
<h2>Serialization</h2>
<p>This part is a bit Typescript specific.</p>
<p>If you have a simple Typescript interface, you can return that very easily from an API endpoint,
because it maps directly to JSON. Most frameworks will provide a way to just "send" the object
itself:</p>
<div class="gatsby-highlight" data-language="js"><pre class="language-js"><code class="language-js">app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/endpoint'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">{</span>woah<span class="token operator">:</span> <span class="token string">'mama'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></div>
<p>This is real convenient.</p>
<p>Now, if you have a class, you have a problem. You can't directly send the class as JSON, now you
need to write logic to serialize your class to JSON, and logic to parse your class back from the
JSON on the frontend.</p>
<p>If you try to just naively <code class="language-text">JSON.stringify</code> it, you'll realize that the methods don't serialize
and can't be parsed back, so you need to always go through the class constructor on both ends.</p>
<p>To work around this, you can separate the "methods" of your class into functions, and then just
work with an interface, but that kind of defeats the point of using a class in the first place.</p>
<h2>Do you really need to share everything?</h2>
<p>The serialization problems are more of an inconvenience. The biggest problem I have with this
"share" everything approach, is that you might be sharing things you don't need on the frontend,
or calculating things on the frontend you could have done in advance.</p>
<p>For example, some fields that are necessary in the backend might not be needed on the frontend. One
common example is the ubiquitous <code class="language-text">id</code> field, On the backend you're going to be using this one a lot,
but on the frontend, you usually don't need the <code class="language-text">id</code> of something, outside of the URL. Having
to send this each time is a bit of a waste.</p>
<p>The frontend usually wants <em>the result</em> of a method, and not the logic of method. For example,
if a user has an array of Tweets as part of their representation, the frontend may want to
know the count. They may want just the count, and not even the tweets themselves. This share
everything approach will send the tweets unnecessarily, and then make the frontend calculate
the count iself.</p>
<p>We could also include the count as part of the backend representation, but this becomes awkward
if we don't need the count for certain frontend things.</p>
<h2>Needs aren't uniform across the frontend.</h2>
<p>We've talked about sharing code in a general sense, but we haven't really talked about the needs
of a frontend specifically. One aspect of a frontend you might not think about initially is how
the needs of your representation change based on which part of the frontend you're at. For example
if I'm displaying all the posts, I don't need their <em>content</em>, I just need the metadata. I only
need everything about the post on the page dedicated to that post.</p>
<p>If my API always returns everything about the post, that's quite a waste for the main page,
where I'm requesting all posts, but only using a fraction of the data for each post.</p>
<p>Because of these varying needs, there isn't a single representation of a concept on the frontend.
Rather, there's multiple <em>slices</em> of the same concept, which includes <strong>all</strong> the things you
might want to know about some entity. Ideally, you'd share this inclusive concept with the frontend,
and then allow it select which subset of information it needs for a specific part of the application.</p>
<h1>What do I advocate then?</h1>
<p>In one word: <a href="https://graphql.org/"><strong>GraphQL</strong></a>.</p>
<p>I've been hinting at it in the way I've described certain problems, and certain needs
the frontend has. In brief I think your "shared representation" should be the GraphQL structure
you provide, and the frontend can have as many slices of that representation as it needs. This
structure should not mirror the data you store, but rather provide both the data the frontend
might need, as well as the calculations it might want to do.</p>
<p>With GraphQL, you provide all the data and calculations the frontend might want, and then each
part of the frontend can make requests for exactly the parts they need. This prevents the oversharing
of unnecessary info, since each part of the frontend can just request the fields it needs.</p>
<p>This approach also helps avoid duplicate logic, by keeping it in the backend. Since a lot of the
methods we had previously have now become GraphQl fields, we no longer share or duplicate the
logic in the frontend. Instead, the frontend just sees the logic as if it were a static field,
which simplifies the work your frontend has to do. You can also take advantage of caching, to
avoid recalculating things. Caching class methods is possible, but a lot less convenient.</p>
<p>You're also free to handle things however you want on the backend. You just need to implement
your resolvers. The frontend doesn't need to know which fields are stored in the database,
which are calculated, and what's actually stored in the database. The backend and the frontend
are now very decoupled, but still share a nice source of truth. GraphQL completely eliminates
the problem of serialization across API boundaries, since it will massage things to and from
JSON for you.</p>
<h2>User-Centric Graph</h2>
<p>You also want to avoid providing an all encompassing Graph. Instead, your graph should take a viewpoint
more specific to your application. For example, if you have a frontend application where users
interact with data specific to them, and don't have access to other user's data, then you should
provide a Graph that reflects that reality.</p>
<p>In this case, you'd have a field for the current user, rather than a field for all users, since
your frontend shouldn't be displaying all the users anyways.</p>
<p>Do:</p>
<div class="gatsby-highlight" data-language="graphql"><pre class="language-graphql"><code class="language-graphql"><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">me</span><span class="token punctuation">:</span> User<span class="token operator">!</span>
<span class="token punctuation">}</span></code></pre></div>
<p>Instead of:</p>
<div class="gatsby-highlight" data-language="graphql"><pre class="language-graphql"><code class="language-graphql"><span class="token keyword">type</span> <span class="token class-name">Query</span> <span class="token punctuation">{</span>
  <span class="token attr-name">myUserID</span><span class="token punctuation">:</span> ID<span class="token operator">!</span>
  <span class="token attr-name">user</span><span class="token punctuation">(</span><span class="token variable">$userID</span><span class="token punctuation">:</span> ID<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">:</span> User<span class="token operator">!</span>
<span class="token punctuation">}</span></code></pre></div>
<p>This does mean that you may end up with multiple GraphQL endpoints over a single database, which
is a good thing. You might want to provide one representation optimized for your frontend
application, and another for your analytics dashboard. This is normal, since the needs and access
restrictions of both applications are very different.</p>
<h1>Conclusion</h1>
<p>I think you should make sharing classes and logic between the backend and frontend of your application
the exception, and not the the rule. The rule should be to share things by putting them into
your GraphQL representation. This representation acts both as a contract / source of truth between
both sides, will letting them be sufficiently decoupled.</p>
<p>Hopefully this post was useful, and I plan to supplement it with an example application, at some point.</p></div></div></div></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/posts/against-fullstack-data-sharing";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"app":["/app-91e2c058516df8769a9d.js"],"component---src-templates-post-js":["/component---src-templates-post-js-1dc6a74bfbadd02f5f31.js"],"component---src-templates-taglist-js":["/component---src-templates-taglist-js-cb8a0a3e4d315e7934da.js"],"component---src-pages-index-js":["/component---src-pages-index-js-ca0301491629684c3195.js"],"component---src-pages-posts-js":["/component---src-pages-posts-js-453a1c3b5cbb98505d2b.js"],"component---src-pages-projects-js":["/component---src-pages-projects-js-6692528894bd75450d1a.js"]};/*]]>*/</script><script src="/component---src-templates-post-js-1dc6a74bfbadd02f5f31.js" async=""></script><script src="/commons-5d8df6b41bcacf3ad498.js" async=""></script><script src="/app-91e2c058516df8769a9d.js" async=""></script><script src="/styles-a307afcb1c8432acadfb.js" async=""></script><script src="/webpack-runtime-b70c3b8306dda07e717b.js" async=""></script></body></html>